C51 COMPILER V9.59.0.0   MAIN_F0M1                                                         04/13/2021 07:57:16 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE MAIN_F0M1
OBJECT MODULE PLACED IN .\Objects\main_F0M1.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE main_F0M1.c LARGE OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Li
                    -stings\main_F0M1.lst) TABS(2) OBJECT(.\Objects\main_F0M1.obj)

line level    source

   1          //-----------------------------------------------------------------------------
   2          // UART0_Int1.c
   3          //-----------------------------------------------------------------------------
   4          // Copyright 2001 Cygnal Integrated Products, Inc.
   5          //// AUTH: BW// DATE: 28 AUG 01
   6          //// This program configures UART0 to operate in interrupt mode, showing an
   7          // example of a string transmitter and a string receiver.  These strings are
   8          // assumed to be NULL-terminated.
   9          //// Assumes an 22.1184MHz crystal is attached between XTAL1 and XTAL2.
  10          // // The system clock frequency is stored in a global constant SYSCLK.  The
  11          // target UART baud rate is stored in a global constant BAUDRATE.//
  12          // Target: C8051F02x
  13          // Tool chain: KEIL C51 6.03 / KEIL EVAL C51//
  14          //-----------------------------------------------------------------------------
  15          // Includes
  16          //-----------------------------------------------------------------------------
  17          #include <c8051f020.h> // SFR declarations
  18          
  19          #include <stdio.h>
  20          #include <string.h>
  21          #include <stdlib.h>
  22          
  23          #include <FO_M1__Structures_COMMANDES_INFORMATIONS_CentraleDeCommande.h>
  24          //-----------------------------------------------------------------------------
  25          // 16-bit SFR Definitions for ‘F02x
  26          //-----------------------------------------------------------------------------
  27          sfr16 DP       = 0x82;                 
  28          // data pointer
  29          sfr16 TMR3RL   = 0x92;
  30          // Timer3 reload value
  31          sfr16 TMR3     = 0x94;
  32          // Timer3 counter
  33          sfr16 ADC0     = 0xbe;
  34          // ADC0 data
  35          sfr16 ADC0GT   = 0xc4;
  36          // ADC0 greater than window
  37          sfr16 ADC0LT   = 0xc6;
  38          // ADC0 less than window
  39          sfr16 RCAP2    = 0xca;
  40          // Timer2 capture/reload
  41          sfr16 T2       = 0xcc;
  42          // Timer2
  43          sfr16 RCAP4    = 0xe4;
  44          // Timer4 capture/reload
  45          sfr16 T4       = 0xf4;
  46          // Timer4
  47          sfr16 DAC0     = 0xd2;
  48          // DAC0 data
  49          sfr16 DAC1     = 0xd5;
  50          // DAC1 data
  51          
  52          //-----------------------------------------------------------------------------
  53          // Global CONSTANTS
  54          //-----------------------------------------------------------------------------
C51 COMPILER V9.59.0.0   MAIN_F0M1                                                         04/13/2021 07:57:16 PAGE 2   

  55          #define SYSCLK       22118400          
  56          // SYSCLK frequency in Hz
  57          #define BAUDRATE     19200
  58          // Baud rate of UART in bps
  59          
  60          sbit LED = P1^6; // LED = 1 means ON
  61          
  62          struct COMMANDES commandes; //On declare une structure commande
  63          struct INFORMATIONS informations; //On declare une structure information
  64          //-----------------------------------------------------------------------------
  65          // Function PROTOTYPES
  66          //-----------------------------------------------------------------------------
  67          void SYSCLK_Init (void);
  68          void PORT_Init (void);
  69          void UART0_Init (void);
  70          
  71          
  72          
  73          void HQ_CM (void);
  74          void CM_HQ (void);
  75          
  76          void Send_char (char);
  77          void Send_string(char*);
  78          char Recup_char(void);
  79          
  80          char separ_cmd(char*, char*);
  81          void analyse_cmd(void);
  82          void decoup_clef_val(char*, char*, char*);
  83          
  84          void Reset_buff_ptr(void);
  85          void Struct_init(void);
  86          
  87          //-----------------------------------------------------------------------------
  88          // Global VARIABLES
  89          //-----------------------------------------------------------------------------
  90          bit TX_Ready;
  91          // ‘1’ means okay to TX
  92          char *TX_ptr;
  93          // pointer to string to transmit
  94          bit RX_Ready;
  95          // ‘1’ means RX string received
  96          
  97          char RX_Buf[50]="";
  98          char* RX_ptr=&RX_Buf[0];
  99          // receive string storage buffer
 100          
 101          char CMD[15]=""; // Buffer de sauvegarde de la commande
 102          char* ptr_CMD = &CMD[0];
 103          
 104          char PARAM_1[10]=""; // Buffer de sauvegarde des param 1
 105          char* ptr_PARAM_1 = &PARAM_1[0];
 106          
 107          char PARAM_2[10]=""; // Buffer de sauvegarde des param 2
 108          char* ptr_PARAM_2 = &PARAM_2[0];
 109          
 110          char PARAM_3[10]=""; // Buffer de sauvegarde des param 3
 111          char* ptr_PARAM_3 = &PARAM_3[0];
 112          
 113          char PARAM_4[10]=""; // Buffer de sauvegarde des param 4
 114          char* ptr_PARAM_4 = &PARAM_4[0];
 115          
 116          
C51 COMPILER V9.59.0.0   MAIN_F0M1                                                         04/13/2021 07:57:16 PAGE 3   

 117          
 118          char buf_clef[15];
 119          char buf_val[15];
 120          
 121          char test[5];
 122          
 123          int nb_cmd;
 124          int s_cmd;
 125          int commande_valide;
 126          
 127          
 128          //-----------------------------------------------------------------------------
 129          // MAIN Routine
 130          //-----------------------------------------------------------------------------
 131          void main (void) {
 132   1      
 133   1        WDTCN = 0xde; // disable watchdog timer
 134   1        WDTCN = 0xad;
 135   1        
 136   1        SYSCLK_Init(); // initialize oscillator
 137   1        PORT_Init (); // initialize crossbar and GPIO   
 138   1        UART0_Init (); // initialize UART0   
 139   1        
 140   1        Struct_init(); //Init des valeurs de la struct
 141   1        
 142   1        Send_string("Tapez une cmd ");
 143   1      
 144   1        while (1){
 145   2            if(RI0 == 1)
 146   2              {
 147   3                HQ_CM();
 148   3              }
 149   2            CM_HQ();  
 150   2          }
 151   1      }
 152          
 153          
 154          //-----------------------------------------------------------------------------
 155          // Initialization Subroutines
 156          //-----------------------------------------------------------------------------
 157          // Sous routines d'initialisation du système de réception
 158          //-----------------------------------------------------------------------------
 159          // SYSCLK_Init
 160          //-----------------------------------------------------------------------------//
 161          // This routine initializes the system clock to use an 22.1184MHz crystal
 162          // as its clock source.
 163          //
 164          void SYSCLK_Init (void){
 165   1        int i;
 166   1        // delay counter
 167   1        OSCXCN = 0x67;
 168   1        // start external oscillator with
 169   1        // 22.1184MHz crystal
 170   1        for (i=0; i < 256; i++) ;
 171   1        // wait for XTLVLD to stabilize
 172   1        while (!(OSCXCN & 0x80)) ;
 173   1        // Wait for crystal osc. to settle
 174   1        OSCICN = 0x88;
 175   1        // select external oscillator as SYSCLK
 176   1        // source and enable missing clock
 177   1        // detector
 178   1        }
C51 COMPILER V9.59.0.0   MAIN_F0M1                                                         04/13/2021 07:57:16 PAGE 4   

 179          //-----------------------------------------------------------------------------
 180          // PORT_Init Configure the Crossbar and GPIO ports
 181          //-----------------------------------------------------------------------------
 182          void PORT_Init (void){
 183   1          XBR0    |= 0x04;
 184   1          // Enable UART0
 185   1          XBR2    |= 0x40;
 186   1          // Enable crossbar and weak pull-ups  
 187   1          P0MDOUT |= 0x01;
 188   1          // enable TX0 as a push-pull output  
 189   1          P1MDOUT |= 0x40;
 190   1          // enable LED as push-pull output
 191   1          }
 192          //-----------------------------------------------------------------------------
 193          // UART0_Init  Configure the UART0 using Timer1, for <baudrate> and 8-N-1.
 194          //-----------------------------------------------------------------------------
 195          void UART0_Init (void){
 196   1            SCON0  = 0x50; // SCON0: mode 1, 8-bit UART, enable RX
 197   1            TMOD   = 0x20; // TMOD: timer 1, mode 2, 8-bit reload 
 198   1            TH1    = -(SYSCLK/BAUDRATE/16); // set Timer1 reload value for baudrate
 199   1            TR1    = 1; // start Timer1
 200   1            CKCON |= 0x10; // Timer1 uses SYSCLK as time base
 201   1            PCON  |= 0x80; // SMOD00 = 1
 202   1            ES0    = 1; // enable UART0 interrupts
 203   1            TX_Ready = 1; // indicate TX ready for transmit 
 204   1            RX_Ready = 0; // indicate RX string not ready
 205   1            TX_ptr = NULL;
 206   1      }
 207              
 208          
 209          //-----------------------------------------------------------------------------
 210          // HQ_CM Sous-routine d'écriture de Commande 
 211          //-----------------------------------------------------------------------------
 212          void HQ_CM(void)
 213            {
 214   1          char char_unique;
 215   1          
 216   1          char_unique = Recup_char(); // On récupère le caractère reçu.
 217   1          
 218   1          *RX_ptr = char_unique; // On stocke ds le buffer tout les caractères.
 219   1          *(RX_ptr + 1) = '\0';
 220   1          RX_ptr++;
 221   1          
 222   1          Send_char(char_unique); // On le renvoie pour savoir ce qu'on a tapé
 223   1          
 224   1          
 225   1          if (char_unique == '\r')
 226   1          {
 227   2            Send_char('\n'); // retour à la ligne
 228   2            
 229   2            Reset_buff_ptr(); // On initialise nos buffers à vide pour être certain de connaitre leur contenu
 230   2            
 231   2            // On commence à séparer le contenu de RX_Buf en sous buffers appropriés.
 232   2            separ_cmd(RX_ptr , ptr_CMD );
 233   2            
 234   2            if(separ_cmd(RX_ptr , ptr_PARAM_1)!=-1)
 235   2            {
 236   3              nb_cmd=0;
 237   3            }
 238   2            
 239   2            if(separ_cmd(RX_ptr , ptr_PARAM_2)!=-1)
 240   2            {
C51 COMPILER V9.59.0.0   MAIN_F0M1                                                         04/13/2021 07:57:16 PAGE 5   

 241   3              nb_cmd=1;
 242   3            }
 243   2            
 244   2            if(separ_cmd(RX_ptr , ptr_PARAM_3)!=-1)
 245   2            {
 246   3              nb_cmd=2;
 247   3            }
 248   2            
 249   2            if(separ_cmd(RX_ptr , ptr_PARAM_4)!=-1)
 250   2            {
 251   3              nb_cmd=3;
 252   3            }
 253   2            else nb_cmd=4;
 254   2            
 255   2      
 256   2            
 257   2            
 258   2            analyse_cmd();
 259   2            
 260   2            
 261   2            switch(s_cmd)
 262   2            {     // Int or Enum type !
 263   3            
 264   3              
 265   3            case 0: 
 266   3              Send_string("Cas 0");
 267   3              break;
 268   3            
 269   3            
 270   3            case 1:
 271   3              Send_string("D");
 272   3              if(nb_cmd == 0)
 273   3                {
 274   4                  commandes.Etat_Epreuve = 1;
 275   4                }
 276   3              else //Un argument : le n° de l'epreuve
 277   3                {
 278   4                  if(0<atoi(PARAM_1) && 9>atoi(PARAM_1))
 279   4                    {
 280   5                      commandes.Etat_Epreuve = atoi(PARAM_1); 
 281   5                    }
 282   4          //Sinon commande invalide
 283   4              else
 284   4                  {
 285   5                    commande_valide = 0;
 286   5                  }
 287   4                }
 288   3              break;
 289   3            
 290   3            case 2:
 291   3              Send_string("E");
 292   3            commandes.Etat_Epreuve = 9;
 293   3              break;
 294   3            
 295   3            case 3:
 296   3              Send_string("Q");
 297   3            commandes.Etat_Epreuve = 10;
 298   3              break;
 299   3            
 300   3            case 4:
 301   3              Send_string("TV");
 302   3              if(nb_cmd == 1)
C51 COMPILER V9.59.0.0   MAIN_F0M1                                                         04/13/2021 07:57:16 PAGE 6   

 303   3                {
 304   4                  if(5>atoi(PARAM_1) && 101>atoi(PARAM_1))
 305   4                    {
 306   5                      commandes.V_defaut = atoi(PARAM_1);
 307   5                    }
 308   4                }
 309   3              else
 310   3                  {
 311   4                    commande_valide = 0;
 312   4                  }
 313   3              break;
 314   3            
 315   3            case 5:
 316   3              Send_string("A");
 317   3              if(nb_cmd == 0)
 318   3                {
 319   4                  commandes.Vitesse = commandes.V_defaut;
 320   4                  commandes.Etat_Mouvement = Avancer;
 321   4                }
 322   3          else
 323   3          {
 324   4            if(5>atoi(PARAM_1) && 101>atoi(PARAM_1))
 325   4            {
 326   5              commandes.Vitesse = atoi(PARAM_1);
 327   5              commandes.Etat_Mouvement = Avancer;
 328   5            }
 329   4            else
 330   4            {
 331   5              commande_valide = 0;
 332   5            }
 333   4          }
 334   3              break;
 335   3            
 336   3            case 6:
 337   3              Send_string("B");
 338   3              if(nb_cmd == 0)
 339   3          {
 340   4            commandes.Vitesse = commandes.V_defaut;
 341   4            commandes.Etat_Mouvement = Reculer;
 342   4          }
 343   3          else
 344   3          {
 345   4            if(5>atoi(PARAM_1) && 101>atoi(PARAM_1))
 346   4            {
 347   5              commandes.Vitesse = atoi(PARAM_1);
 348   5              commandes.Etat_Mouvement = Reculer;
 349   5            }
 350   4            else
 351   4            {
 352   5              commande_valide = 0;
 353   5            }
 354   4          }
 355   3              break;
 356   3            
 357   3            case 7:
 358   3              Send_string("S");
 359   3              commandes.Etat_Mouvement = Stopper;
 360   3              break;
 361   3            
 362   3            case 8:
 363   3              Send_string("RD");
 364   3              commandes.Etat_Mouvement = Rot_90D;
C51 COMPILER V9.59.0.0   MAIN_F0M1                                                         04/13/2021 07:57:16 PAGE 7   

 365   3              break;
 366   3            
 367   3            case 9:
 368   3              Send_string("RG");
 369   3              commandes.Etat_Mouvement = Rot_90G;
 370   3              
 371   3              break;
 372   3            
 373   3            case 10:
 374   3              Send_string("RC");
 375   3              if(nb_cmd == 0)
 376   3                {
 377   4                  commande_valide = 0;
 378   4                }
 379   3        
 380   3                else
 381   3                  {
 382   4                    if(strcmp(PARAM_1, "D") == 0)
 383   4                      {
 384   5                        commandes.Etat_Mouvement = Rot_180D;
 385   5      
 386   5                      }
 387   4                    else if(strcmp(PARAM_1, "G") == 0)
 388   4                        {
 389   5                          commandes.Etat_Mouvement = Rot_180G;
 390   5                        }
 391   4                    else{
 392   5                          commande_valide = 0;
 393   5                        }
 394   4                  }
 395   3          
 396   3              break;
 397   3            
 398   3            case 11:
 399   3              Send_string("RA");
 400   3            
 401   3              if(nb_cmd == 0)
 402   3                {
 403   4                  commandes.Etat_Mouvement = Rot_AngD;
 404   4                  commandes.Angle = 90;
 405   4                }
 406   3        
 407   3        
 408   3              else
 409   3                { 
 410   4                  decoup_clef_val(PARAM_1, buf_clef, buf_val);
 411   4            //Si droite et ecrit correctement
 412   4                  if(strcmp(buf_clef, "D") == 0 &&
 413   4                    atoi(buf_val) > 0 &&
 414   4                    atoi(buf_val) < 181)
 415   4                  {
 416   5                    commandes.Etat_Mouvement = Rot_AngD;
 417   5                    commandes.Angle = atoi(buf_val);
 418   5            }
 419   4            else if(strcmp(buf_clef, "G") == 0 && atoi(buf_val) > 0 && atoi(buf_val) < 181)
 420   4              {
 421   5                commandes.Etat_Mouvement = Rot_AngG;
 422   5                commandes.Angle = atoi(buf_val);
 423   5              }
 424   4            else{
 425   5              commande_valide = 0;
 426   5            }
C51 COMPILER V9.59.0.0   MAIN_F0M1                                                         04/13/2021 07:57:16 PAGE 8   

 427   4          }
 428   3              break;
 429   3            
 430   3            case 12:
 431   3              Send_string("G");
 432   3            
 433   3              if(nb_cmd != 3)
 434   3                {
 435   4                  commande_valide = 0;
 436   4                }
 437   3              else 
 438   3                {
 439   4                
 440   4                  decoup_clef_val(PARAM_1, buf_clef, buf_val);
 441   4      
 442   4                  if((strcmp(buf_clef, "X") == 0) && ((-100 < atoi(buf_val)) && (100 > atoi(buf_val))))
 443   4                    {
 444   5                      commandes.Etat_Mouvement = Depl_Coord;
 445   5                      commandes.Coord_X = atoi(buf_val);
 446   5                    }
 447   4      
 448   4                  else if((strcmp(buf_clef, "Y") == 0) && ((-100 < atoi(buf_val)) && (100 > atoi(buf_val))) && command
             -e_valide != 0)
 449   4                    {
 450   5                      commandes.Coord_Y = atoi(buf_val);
 451   5                    }
 452   4      
 453   4                  else if((strcmp(buf_clef, "A") == 0) && ((-181 < atoi(buf_val)) && (181 > atoi(buf_val))) && command
             -e_valide != 0)
 454   4                    {
 455   5                      commandes.Angle = atoi(buf_val);
 456   5                    }
 457   4      
 458   4                  else
 459   4                    {
 460   5                      commande_valide = 0;
 461   5                    }
 462   4          
 463   4        
 464   4                  decoup_clef_val(PARAM_2, buf_clef, buf_val);
 465   4      
 466   4                  if((strcmp(buf_clef, "Y") == 0) && ((-100 < atoi(buf_val)) && (100 > atoi(buf_val))))
 467   4                    {
 468   5                      commandes.Coord_X = atoi(buf_val);
 469   5                    }
 470   4      
 471   4                  else if((strcmp(buf_clef, "X") == 0) && ((-100 < atoi(buf_val)) && (100 > atoi(buf_val))) && command
             -e_valide != 0)
 472   4                    {
 473   5                      commandes.Coord_Y = atoi(buf_val);
 474   5                    }
 475   4      
 476   4                  else if((strcmp(buf_clef, "A") == 0) && ((-181 < atoi(buf_val)) && (181 > atoi(buf_val))) && command
             -e_valide != 0)
 477   4                    {
 478   5                      commandes.Angle = atoi(buf_val);
 479   5                    }
 480   4      
 481   4                  else
 482   4                    {
 483   5                      commande_valide = 0;
 484   5                    }
C51 COMPILER V9.59.0.0   MAIN_F0M1                                                         04/13/2021 07:57:16 PAGE 9   

 485   4          
 486   4                  
 487   4                  decoup_clef_val(PARAM_3, buf_clef, buf_val);
 488   4      
 489   4                  if((strcmp(buf_clef, "A") == 0) && ((-181 < atoi(buf_val)) && (181 > atoi(buf_val))) && commande_val
             -ide != 0)
 490   4                  {
 491   5                    commandes.Angle = atoi(buf_val);
 492   5                  }
 493   4      
 494   4                  else if((strcmp(buf_clef, "Y") == 0) && ((-100 < atoi(buf_val)) && (100 > atoi(buf_val))))
 495   4                    {
 496   5                      commandes.Coord_X = atoi(buf_val);
 497   5                    }
 498   4      
 499   4                  else if((strcmp(buf_clef, "X") == 0) && ((-100 < atoi(buf_val)) && (100 > atoi(buf_val))) && command
             -e_valide != 0)
 500   4                    {
 501   5                      commandes.Coord_Y = atoi(buf_val);
 502   5                    }
 503   4      
 504   4                  else
 505   4                    {
 506   5                      commande_valide = 0;
 507   5                    }
 508   4          //Si un des arguments est invalide, on remet tout a 0
 509   4                  if(commande_valide == 0)
 510   4                    {
 511   5                      commandes.Etat_Mouvement = Mouvement_non;
 512   5                      commandes.Coord_X = 0;
 513   5                      commandes.Coord_Y = 0;
 514   5                      commandes.Angle = 0;
 515   5                    }
 516   4                }
 517   3              break;
 518   3            
 519   3            case 13:
 520   3              Send_string("ASS");
 521   3              if(nb_cmd == 0)
 522   3                {
 523   4                  commande_valide = 0;
 524   4                }
 525   3        
 526   3              if(atoi(PARAM_1) > 0 && atoi(PARAM_1) < 99)
 527   3                {
 528   4                  commandes.ACQ_Duree = atoi(PARAM_1);
 529   4                  commandes.Etat_ACQ_Son = ACQ_oui;
 530   4                }
 531   3              else
 532   3                {
 533   4                  commande_valide = 0;
 534   4                }
 535   3              break;
 536   3            
 537   3            case 14: // Mesure conso courant pas encore implémenté
 538   3              Send_string("MI");
 539   3              commandes.Etat_Energie = Mesure_I;
 540   3              break;
 541   3            
 542   3            case 15: // Mesure conso energie pas encore implémenté
 543   3              Send_string("ME");
 544   3              commandes.Etat_Energie = Mesure_E;
C51 COMPILER V9.59.0.0   MAIN_F0M1                                                         04/13/2021 07:57:16 PAGE 10  

 545   3              break;
 546   3            
 547   3            case 16:
 548   3              Send_string("IPO");
 549   3            
 550   3              if(nb_cmd != 3)
 551   3                {
 552   4                  commande_valide = 0;
 553   4                }
 554   3              else 
 555   3                {
 556   4                  decoup_clef_val(PARAM_1, buf_clef, buf_val);
 557   4                  if((strcmp(buf_clef, "X") == 0) && ((-100 < atoi(buf_val)) && (100 > atoi(buf_val))))
 558   4                    {
 559   5                      commandes.Etat_Position = Init_Position;
 560   5                      commandes.Pos_Coord_X = atoi(buf_val);
 561   5                    }
 562   4      
 563   4              else if((strcmp(buf_clef, "Y") == 0) && ((-100 < atoi(buf_val)) && (100 > atoi(buf_val))) && comma
             -nde_valide != 0)
 564   4              {
 565   5                commandes.Pos_Coord_Y = atoi(buf_val);
 566   5              }
 567   4      
 568   4              else if((strcmp(buf_clef, "A") == 0) && ((-181 < atoi(buf_val)) && (181 > atoi(buf_val))) && comma
             -nde_valide != 0)
 569   4              {
 570   5                commandes.Pos_Angle = atoi(buf_val);
 571   5              }
 572   4      
 573   4              else
 574   4                {
 575   5                  commande_valide = 0;
 576   5                }
 577   4          
 578   4          //Deuxieme argument si le premier est fait
 579   4          decoup_clef_val(PARAM_2, buf_clef, buf_val);
 580   4      
 581   4          if((strcmp(buf_clef, "Y") == 0) && ((-100 < atoi(buf_val)) && (100 > atoi(buf_val))))
 582   4            {
 583   5              commandes.Pos_Coord_X = atoi(buf_val);
 584   5            }
 585   4      
 586   4              else if((strcmp(buf_clef, "X") == 0) && ((-100 < atoi(buf_val)) && (100 > atoi(buf_val))) && comma
             -nde_valide != 0)
 587   4              {
 588   5                commandes.Pos_Coord_Y = atoi(buf_val);
 589   5              }
 590   4      
 591   4              else if((strcmp(buf_clef, "A") == 0) && ((-181 < atoi(buf_val)) && (181 > atoi(buf_val))) && comma
             -nde_valide != 0)
 592   4              {
 593   5                commandes.Pos_Angle = atoi(buf_val);
 594   5              }
 595   4      
 596   4          else
 597   4            {
 598   5              commande_valide = 0;
 599   5            }
 600   4          
 601   4          //Troisieme argument
 602   4          decoup_clef_val(PARAM_3, buf_clef, buf_val);
C51 COMPILER V9.59.0.0   MAIN_F0M1                                                         04/13/2021 07:57:16 PAGE 11  

 603   4      
 604   4          if((strcmp(buf_clef, "A") == 0) && ((-181 < atoi(buf_val)) && (181 > atoi(buf_val))) && commande_valide 
             -!= 0)
 605   4            {
 606   5              commandes.Pos_Angle = atoi(buf_val);
 607   5            }
 608   4      
 609   4          else if((strcmp(buf_clef, "Y") == 0) && ((-100 < atoi(buf_val)) && (100 > atoi(buf_val))))
 610   4            {
 611   5              commandes.Pos_Coord_X = atoi(buf_val);
 612   5            }
 613   4      
 614   4          else if((strcmp(buf_clef, "X") == 0) && ((-100 < atoi(buf_val)) && (100 > atoi(buf_val))) && commande_
             -valide != 0)
 615   4          {
 616   5            commandes.Pos_Coord_Y = atoi(buf_val);
 617   5          }
 618   4      
 619   4          else
 620   4            {
 621   5              commande_valide = 0;
 622   5            }
 623   4          }
 624   3          
 625   3          if(commande_valide == 0)
 626   3            {
 627   4              commandes.Etat_Mouvement = Mouvement_non;
 628   4              commandes.Pos_Coord_X = 0;
 629   4              commandes.Pos_Coord_Y = 0;
 630   4              commandes.Pos_Angle = 0;
 631   4            }
 632   3            
 633   3              break;
 634   3            
 635   3            case 17:
 636   3              Send_string("POS");
 637   3              commandes.Etat_Position = Demande_Position;
 638   3              break;
 639   3            
 640   3            case 18:
 641   3              test[0] = 'M';
 642   3              test[1] = 'O';
 643   3              test[2] = 'U';
 644   3              test[3] = '\r';
 645   3              break;
 646   3            
 647   3            case 19:
 648   3              Send_string("MOB");
 649   3            
 650   3              switch (nb_cmd)
 651   3                {
 652   4                
 653   4                  case 0:
 654   4                    commandes.Etat_DCT_Obst = oui_360;
 655   4                    commandes.DCT_Obst_Resolution = 30;
 656   4                    break;
 657   4      
 658   4              
 659   4                  case 1:
 660   4                  
 661   4                    if(strcmp(PARAM_1, "D") == 0)
 662   4                      {
C51 COMPILER V9.59.0.0   MAIN_F0M1                                                         04/13/2021 07:57:16 PAGE 12  

 663   5                        commandes.Etat_DCT_Obst = oui_180;
 664   5                      }
 665   4       
 666   4                    else
 667   4                      {
 668   5                        decoup_clef_val(PARAM_1, buf_clef, buf_val);
 669   5                        if(strcmp(buf_clef, "A") == 0 && atoi(buf_val) > 4 && atoi(buf_val) < 46)
 670   5                          {
 671   6                            commandes.DCT_Obst_Resolution = atoi(buf_val);
 672   6                          }
 673   5                      }
 674   4                    break;
 675   4      
 676   4         
 677   4                  case 2:
 678   4                    if(strcmp(PARAM_1, "D") == 0)
 679   4                      {
 680   5                        commandes.Etat_DCT_Obst = oui_180;
 681   5                      }
 682   4       
 683   4      
 684   4                    
 685   4                        decoup_clef_val(PARAM_2, buf_clef, buf_val);
 686   4                        if(strcmp(buf_clef, "A") == 0 && atoi(buf_val) > 4 && atoi(buf_val) < 46)
 687   4                          {
 688   5                            commandes.DCT_Obst_Resolution = atoi(buf_val);
 689   5                          }
 690   4                              
 691   4             
 692   4                        else
 693   4                          {
 694   5                            commande_valide = 0;
 695   5                          }
 696   4                    break;
 697   4       
 698   4                  default:
 699   4                    commande_valide = 0;
 700   4                    break;
 701   4                }
 702   3              break;
 703   3            
 704   3            case 20: // FONCTION NON PROGRAMMEE POUR LE MOMENT  
 705   3              test[0] = 'M';
 706   3              test[1] = 'O';
 707   3              test[2] = 'S';
 708   3              test[3] = '\r';
 709   3              break;
 710   3            
 711   3            case 21: // FONCTION NON PROGRAMMEE POUR LE MOMENT
 712   3              test[0] = 'S';
 713   3              test[1] = 'D';
 714   3              test[2] = '\r';
 715   3              break;
 716   3            
 717   3            case 22:
 718   3              Send_string("L");
 719   3            
 720   3              commandes.Etat_Lumiere = Allumer;
 721   3              commandes.Lumiere_Intensite = 100;
 722   3              commandes.Lumiere_Duree = 99;
 723   3              commandes.Lumire_Extinction = 0;
 724   3              commandes.Lumiere_Nbre = 1;
C51 COMPILER V9.59.0.0   MAIN_F0M1                                                         04/13/2021 07:57:16 PAGE 13  

 725   3      
 726   3              if(nb_cmd != 0)
 727   3                {
 728   4                  decoup_clef_val(PARAM_1, buf_clef, buf_val);
 729   4                  if(strcmp(buf_clef, "I") == 0 && 0 < atoi(buf_val) && 101 > atoi(buf_val))
 730   4                    {
 731   5                      commandes.Lumiere_Intensite = atoi(buf_val);
 732   5                    }
 733   4                  else if(strcmp(buf_clef, "D") == 0 && 0 < atoi(buf_val) && 100 > atoi(buf_val))
 734   4                  {
 735   5                      commandes.Lumiere_Duree = atoi(buf_val);
 736   5                  }
 737   4                  else if(strcmp(buf_clef, "E") == 0 && 0 <= atoi(buf_val) && 100 > atoi(buf_val))
 738   4                  {
 739   5                      commandes.Lumire_Extinction = atoi(buf_val);
 740   5                  }
 741   4                  else if (strcmp(buf_clef, "N") == 0 &&
 742   4                  0 < atoi(buf_val) &&
 743   4                  100 > atoi(buf_val)){
 744   5                      commandes.Lumiere_Nbre = atoi(buf_val);
 745   5              }
 746   4              else{
 747   5                  commande_valide = 0;
 748   5              }
 749   4      
 750   4              decoup_clef_val(PARAM_2, buf_clef, buf_val);
 751   4              if(strcmp(buf_clef, "I") == 0 &&
 752   4                  0 < atoi(buf_val) &&
 753   4                  101 > atoi(buf_val)){
 754   5                      commandes.Lumiere_Intensite = atoi(buf_val);
 755   5              }
 756   4              else if(strcmp(buf_clef, "D") == 0 &&
 757   4                  0 < atoi(buf_val) &&
 758   4                  100 > atoi(buf_val)){
 759   5                      commandes.Lumiere_Duree = atoi(buf_val);
 760   5              }
 761   4              else if(strcmp(buf_clef, "E") == 0 &&
 762   4                  0 <= atoi(buf_val) &&
 763   4                  100 > atoi(buf_val)){
 764   5                      commandes.Lumire_Extinction = atoi(buf_val);
 765   5              }
 766   4              else if (strcmp(buf_clef, "N") == 0 &&
 767   4                  0 < atoi(buf_val) &&
 768   4                  100 > atoi(buf_val)){
 769   5                      commandes.Lumiere_Nbre = atoi(buf_val);
 770   5              }
 771   4              else{
 772   5                  commande_valide = 0;
 773   5              }
 774   4      
 775   4              decoup_clef_val(PARAM_3, buf_clef, buf_val);
 776   4              if(strcmp(buf_clef, "I") == 0 &&
 777   4                  0 < atoi(buf_val) &&
 778   4                  101 > atoi(buf_val)){
 779   5                      commandes.Lumiere_Intensite = atoi(buf_val);
 780   5              }
 781   4              else if(strcmp(buf_clef, "D") == 0 &&
 782   4                  0 < atoi(buf_val) &&
 783   4                  100 > atoi(buf_val)){
 784   5                      commandes.Lumiere_Duree = atoi(buf_val);
 785   5              }
 786   4              else if(strcmp(buf_clef, "E") == 0 &&
C51 COMPILER V9.59.0.0   MAIN_F0M1                                                         04/13/2021 07:57:16 PAGE 14  

 787   4                  0 <= atoi(buf_val) &&
 788   4                  100 > atoi(buf_val)){
 789   5                      commandes.Lumire_Extinction = atoi(buf_val);
 790   5              }
 791   4              else if (strcmp(buf_clef, "N") == 0 &&
 792   4                  0 < atoi(buf_val) &&
 793   4                  100 > atoi(buf_val)){
 794   5                      commandes.Lumiere_Nbre = atoi(buf_val);
 795   5              }
 796   4              else{
 797   5                  commande_valide = 0;
 798   5              }
 799   4      
 800   4              decoup_clef_val(PARAM_4, buf_clef, buf_val);
 801   4              if(strcmp(buf_clef, "I") == 0 &&
 802   4                  0 < atoi(buf_val) &&
 803   4                  101 > atoi(buf_val)){
 804   5                      commandes.Lumiere_Intensite = atoi(buf_val);
 805   5              }
 806   4              else if(strcmp(buf_clef, "D") == 0 &&
 807   4                  0 < atoi(buf_val) &&
 808   4                  100 > atoi(buf_val)){
 809   5                      commandes.Lumiere_Duree = atoi(buf_val);
 810   5              }
 811   4              else if(strcmp(buf_clef, "E") == 0 &&
 812   4                  0 <= atoi(buf_val) &&
 813   4                  100 > atoi(buf_val)){
 814   5                      commandes.Lumire_Extinction = atoi(buf_val);
 815   5              }
 816   4              else if (strcmp(buf_clef, "N") == 0 &&
 817   4                  0 < atoi(buf_val) &&
 818   4                  100 > atoi(buf_val)){
 819   5                      commandes.Lumiere_Nbre = atoi(buf_val);
 820   5              }
 821   4              else{
 822   5                  commande_valide = 0;
 823   5              }
 824   4          }
 825   3      
 826   3          if(commande_valide == 0){
 827   4              commandes.Etat_Lumiere = Lumiere_non;
 828   4          }
 829   3              
 830   3              break;
 831   3            
 832   3            case 23:
 833   3              Send_string("LS");
 834   3              commandes.Etat_Lumiere = Eteindre;
 835   3              break;
 836   3            
 837   3            case 24:
 838   3              Send_string("CS");
 839   3            
 840   3              switch(nb_cmd)
 841   3            {
 842   4              case 0:
 843   4                  commandes.Etat_Servo = Servo_H;
 844   4                  commandes.Servo_Angle = 0;
 845   4                  break;
 846   4              case 1:
 847   4                  
 848   4                      decoup_clef_val(PARAM_1, buf_clef, buf_val);
C51 COMPILER V9.59.0.0   MAIN_F0M1                                                         04/13/2021 07:57:16 PAGE 15  

 849   4                      if(strcmp(buf_clef, "A") == 0 && -100 < atoi(buf_val) && 100 > atoi(buf_val))
 850   4                      {
 851   5                        commandes.Servo_Angle = atoi(buf_val);
 852   5                      }
 853   4                      else
 854   4                        {
 855   5                          commande_valide = 0;
 856   5                        }
 857   4                  
 858   4                      if (strcmp(PARAM_1, "H") == 0)
 859   4                        {
 860   5                          commandes.Etat_Servo = Servo_H;
 861   5                        }
 862   4                  else if (strcmp(PARAM_1, "V") == 0)
 863   4                    {
 864   5                      commandes.Etat_Servo = Servo_V;
 865   5                    }
 866   4                  else
 867   4                    {
 868   5                      commande_valide = 0;
 869   5                    }
 870   4                  break;
 871   4      
 872   4              case 2:
 873   4                  
 874   4                      decoup_clef_val(PARAM_2, buf_clef, buf_val);
 875   4                      if(strcmp(buf_clef, "A") == 0 && -100 < atoi(buf_val) && 100 > atoi(buf_val))
 876   4                        {
 877   5                          commandes.Servo_Angle = atoi(buf_val);
 878   5                        }
 879   4                      else
 880   4                        {
 881   5                          commande_valide = 0;
 882   5                        }
 883   4                  
 884   4                  if (strcmp(PARAM_1, "H") == 0)
 885   4                    {
 886   5                      commandes.Etat_Servo = Servo_H;
 887   5                    }
 888   4                  else if (strcmp(PARAM_1, "V") == 0)
 889   4                    {
 890   5                      commandes.Etat_Servo = Servo_V;
 891   5                    }
 892   4                  else
 893   4                    {
 894   5                      commande_valide = 0;
 895   5                    }
 896   4                  break;
 897   4      
 898   4                  default:
 899   4                      commande_valide = 0;
 900   4                      break;
 901   4          }
 902   3      
 903   3          if(commande_valide == 0)
 904   3            {
 905   4              commandes.Etat_Servo = Servo_non;
 906   4              commandes.Servo_Angle = 0;
 907   4            }
 908   3              break;
 909   3            
 910   3            case 25:
C51 COMPILER V9.59.0.0   MAIN_F0M1                                                         04/13/2021 07:57:16 PAGE 16  

 911   3              Send_string("PPH");
 912   3            
 913   3              commandes.Etat_Photo = Photo_non;
 914   3              commandes.Photo_Duree = 1;
 915   3              commandes.Photo_Nbre = 1;
 916   3      
 917   3                if(strcmp(PARAM_1, "O") == 0)
 918   3                  {
 919   4                    commandes.Etat_Photo = Photo_1;
 920   4                  }
 921   3      
 922   3                else if(strcmp(PARAM_1, "C") == 0)
 923   3                  {
 924   4                    commandes.Etat_Photo = Photo_continue;
 925   4                  }
 926   3      
 927   3                else if(strcmp(PARAM_1, "S") == 0)
 928   3                  {
 929   4                    commandes.Etat_Photo = Photo_Multiple;
 930   4                  }
 931   3      
 932   3                else
 933   3                  {
 934   4                    commande_valide = 0;
 935   4                  }
 936   3                decoup_clef_val(PARAM_2, buf_clef, buf_val);
 937   3                if(strcmp(buf_clef, "E") == 0 && 0 <= atoi(buf_val) && 100 > atoi(buf_val))
 938   3                      {
 939   4                        commandes.Photo_Duree = atoi(buf_val);
 940   4                      }
 941   3                else
 942   3                  {
 943   4                    commande_valide = 0;
 944   4                  }
 945   3      
 946   3            
 947   3                decoup_clef_val(PARAM_3, buf_clef, buf_val);
 948   3                if(strcmp(buf_clef, "N") == 0 && 0 < atoi(buf_val) && 256 > atoi(buf_val))
 949   3                {
 950   4                      commandes.Photo_Nbre = atoi(buf_val);
 951   4                }
 952   3                else
 953   3                  {
 954   4                    commande_valide = 0;
 955   4                  }
 956   3              
 957   3        
 958   3      
 959   3          if(commande_valide == 0)
 960   3            {
 961   4              commandes.Etat_Photo = Photo_non;
 962   4              commandes.Photo_Duree = 1;
 963   4              commandes.Photo_Nbre = 1;
 964   4            }
 965   3              
 966   3              break;
 967   3            
 968   3            case 26:
 969   3              Send_string("SPH");
 970   3              commandes.Etat_Photo = Photo_stop;
 971   3              break;
 972   3            
C51 COMPILER V9.59.0.0   MAIN_F0M1                                                         04/13/2021 07:57:16 PAGE 17  

 973   3            case 27:
 974   3              test[0] = 'A';
 975   3              test[1] = 'U';
 976   3              test[2] = 'X';
 977   3              test[3] = '\r';
 978   3            
 979   3            default:
 980   3              Send_char(0x0D);
 981   3              Send_char(0x0A);
 982   3              Send_char(0x23);
 983   3              break;
 984   3              
 985   3            }
 986   2            Reset_buff_ptr();
 987   2            RX_ptr = &RX_Buf[0]; // On re place le ptr au début. Pour être capable de relancer un cycle.
 988   2          }
 989   1        }
 990            
 991            
 992          //-----------------------------------------------------------------------------
 993          // CM_HQ Sous-routine de retour d'Information
 994          //-----------------------------------------------------------------------------
 995          void CM_HQ(void)
 996            {
 997   1          if(informations.Etat_Invite == Invite_oui){
 998   2              Send_string(informations.MSG_Invit);
 999   2          }
1000   1          //
1001   1          if(informations.Etat_BUT_Mouvement == BUT_Atteint_oui){
1002   2              Send_string("Coordonnees atteintes");
1003   2          }
1004   1          //
1005   1          if(informations.Etat_BUT_Servo == BUT_Servo_H){
1006   2              Send_string("Servo H en place");
1007   2          }
1008   1          else if(informations.Etat_BUT_Servo == BUT_Servo_V){
1009   2              Send_string("Servo V en place");
1010   2          }
1011   1          //
1012   1          if(informations.Etat_DCT_Obst == BUT_Atteint_oui){
1013   2              Send_string("Coordonnees atteintes");
1014   2          }
1015   1          //
1016   1          if(informations.Etat_RESULT_Courant == BUT_Atteint_oui){
1017   2              Send_string("Coordonnees atteintes");
1018   2          }
1019   1          //
1020   1          if(informations.Etat_RESULT_Energie == BUT_Atteint_oui){
1021   2              Send_string("Coordonnees atteintes");
1022   2          }
1023   1          //
1024   1          if(informations.Etat_RESULT_Position == BUT_Atteint_oui){
1025   2              Send_string("Coordonnees atteintes");
1026   2          }
1027   1          //
1028   1          if(informations.Etat_Aux == Aux_oui){
1029   2              Send_string(informations.MSG_Aux);
1030   2          }
1031   1        }
1032          //-----------------------------------------------------------------------------
1033          // send_char et Send_string Sous-routines pour envoyer un char et string
1034          //-----------------------------------------------------------------------------
C51 COMPILER V9.59.0.0   MAIN_F0M1                                                         04/13/2021 07:57:16 PAGE 18  

1035          void Send_char(char c)
1036          {
1037   1        
1038   1        //Desactive reception
1039   1        
1040   1        REN0 = 0;
1041   1        SBUF0 = c;
1042   1        
1043   1        //Attente fin de transmission
1044   1        while(!TI0){}
1045   1          
1046   1        //Remise à 0 du flag d'envoi une fois qu'on est sur que le caractere a été transmis
1047   1        TI0 = 0;
1048   1        REN0 = 1;
1049   1      }
1050          
1051          void Send_string(char* mot)
1052          {
1053   1        
1054   1        //Tant qu'on n'a pas fini de lire toute la chaine
1055   1          while (*mot != '\0'){
1056   2            
1057   2            //Check si on est en train de lire l'avant-dernier caractere (le tout dernier caractere est l'appuie de
             - la touche ENTER)
1058   2            Send_char(*mot);
1059   2            
1060   2            mot++;
1061   2          }
1062   1          
1063   1          Send_char('\r');
1064   1          Send_char('\n'); //Retour à la ligne
1065   1      }
1066          
1067          
1068          
1069          //-----------------------------------------------------------------------------
1070          // Recup_char sous-routine de récupération des char 
1071          //-----------------------------------------------------------------------------
1072          char Recup_char(void)
1073          {
1074   1          
1075   1        char c;
1076   1      
1077   1        //Desactive la reception
1078   1        RI0 = 0;
1079   1        REN0 = 0;
1080   1        
1081   1        //Recup le caractere
1082   1        c = SBUF0;
1083   1        
1084   1        //Reactive la reception
1085   1        REN0 = 1;
1086   1        
1087   1        return c;
1088   1      }
1089          
1090          
1091          //-----------------------------------------------------------------------------
1092          // Sous-routine  decoup_clef_val de découpage clef valeur des param complexes.
1093          //-----------------------------------------------------------------------------
1094          void decoup_clef_val(char* param, char* buf_clef, char* buf_val)
1095          {
C51 COMPILER V9.59.0.0   MAIN_F0M1                                                         04/13/2021 07:57:16 PAGE 19  

1096   1        if(*param == '\0'){
1097   2              *buf_clef = '\0';
1098   2              *buf_val = '\0';
1099   2          }
1100   1          else{
1101   2              //On prend tous les caracteres jusqu'au ':' exclus dans clef
1102   2              while(*param != ':')
1103   2              {
1104   3                      *buf_clef = *param;
1105   3                      buf_clef++;
1106   3              param++;
1107   3              }
1108   2              //Ici on passe les ':'
1109   2              param++;
1110   2          
1111   2              //Puis on lit tout ce qui suit les ':' jusqu'a la fin de la chaine
1112   2              while(*param != '\0')
1113   2              {
1114   3                  *buf_val = *param;
1115   3                  buf_val++;
1116   3                  param++;
1117   3              }
1118   2          }
1119   1      }
1120          //-----------------------------------------------------------------------------
1121          // Sous-routine d'analyse de la chaîne reçu
1122          //-----------------------------------------------------------------------------
1123          char separ_cmd(char* ptr_lecture, char* ptr_buffer){
1124   1      
1125   1      // La fonction returne -1 si il n'y a rien ( ou plus rien à lire) dans le buffer de lecture donné.
1126   1      
1127   1        
1128   1          //On passe les espaces.
1129   1          while(*ptr_lecture == ' '){
1130   2              ptr_lecture++;
1131   2              RX_ptr++;
1132   2          }
1133   1      
1134   1          // cas chaine vide ou avec plus rien à lire
1135   1          if(*ptr_lecture == '\r' || *ptr_lecture == '\0'){
1136   2              return -1;
1137   2          }
1138   1      
1139   1          //On itère dans notre chaine de char
1140   1          while(*ptr_lecture != '\r' && *ptr_lecture != '\0' && *ptr_lecture != ' '){
1141   2              //Copie du char dans le buffer
1142   2              *ptr_buffer = *ptr_lecture;
1143   2              *(ptr_buffer+1) = '\0';
1144   2              ptr_lecture++;
1145   2              RX_ptr++;
1146   2              ptr_buffer++;
1147   2          }
1148   1          return 0;
1149   1        }
1150          
1151            
1152          //-----------------------------------------------------------------------------
1153          // analyse_cmd Sous-routine d'analyse de commande
1154          //-----------------------------------------------------------------------------
1155          void analyse_cmd(void)
1156            {
1157   1          commande_valide = 1;
C51 COMPILER V9.59.0.0   MAIN_F0M1                                                         04/13/2021 07:57:16 PAGE 20  

1158   1          if(strcmp(CMD, "D") == 0)
1159   1            {
1160   2            s_cmd = 1;
1161   2            }
1162   1        else if(strcmp(CMD, "E") == 0)
1163   1          {
1164   2            s_cmd = 2;
1165   2          }
1166   1        else if(strcmp(CMD, "Q") == 0)
1167   1        {
1168   2          s_cmd = 3;
1169   2        }
1170   1        else if(strcmp(CMD, "TV") == 0)
1171   1          {
1172   2          s_cmd = 4;
1173   2          }
1174   1        else if(strcmp(CMD, "A") == 0)
1175   1          {
1176   2          s_cmd = 5;
1177   2          }
1178   1        else if(strcmp(CMD, "B") == 0)
1179   1          {
1180   2          s_cmd = 6;
1181   2          }
1182   1        else if(strcmp(CMD, "S") == 0)
1183   1          {
1184   2          s_cmd = 7;
1185   2          }
1186   1        else if(strcmp(CMD, "RD") == 0)
1187   1          {
1188   2          s_cmd = 8;
1189   2          }
1190   1        else if(strcmp(CMD, "RG") == 0)
1191   1          {
1192   2          s_cmd = 9;
1193   2          } 
1194   1        else if(strcmp(CMD, "RC") == 0)
1195   1          {
1196   2          s_cmd = 10;
1197   2          }
1198   1        else if(strcmp(CMD, "RA") == 0)
1199   1          {
1200   2          s_cmd = 11;
1201   2        }
1202   1        else if(strcmp(CMD, "G") == 0)
1203   1          {
1204   2          s_cmd = 12;
1205   2        }
1206   1        else if(strcmp(CMD, "ASS") == 0)
1207   1          {
1208   2          s_cmd = 13;
1209   2        }
1210   1        else if(strcmp(CMD, "MI") == 0)
1211   1          {
1212   2          s_cmd = 14;
1213   2        }
1214   1        else if(strcmp(CMD, "ME") == 0)
1215   1          {
1216   2          s_cmd = 15;
1217   2        }
1218   1        else if(strcmp(CMD, "IPO") == 0)
1219   1          {
C51 COMPILER V9.59.0.0   MAIN_F0M1                                                         04/13/2021 07:57:16 PAGE 21  

1220   2          s_cmd = 16;
1221   2        }
1222   1        else if(strcmp(CMD, "POS") == 0)
1223   1          {
1224   2          s_cmd = 17;
1225   2        }
1226   1        else if(strcmp(CMD, "MOU") == 0)
1227   1          {
1228   2          s_cmd = 18;
1229   2        }
1230   1        else if(strcmp(CMD, "MOB") == 0)
1231   1          {
1232   2          s_cmd = 19;
1233   2        }
1234   1        else if(strcmp(CMD, "MOS") == 0)
1235   1          {
1236   2          s_cmd = 20;
1237   2        }
1238   1        else if(strcmp(CMD, "SD") == 0)
1239   1          {
1240   2          s_cmd = 21;
1241   2        }
1242   1        else if(strcmp(CMD, "L") == 0)
1243   1          {
1244   2          s_cmd = 22;
1245   2        }
1246   1        else if(strcmp(CMD, "LS") == 0)
1247   1          {
1248   2          s_cmd = 23;
1249   2        }
1250   1        else if(strcmp(CMD, "CS") == 0)
1251   1          {
1252   2          s_cmd = 24;
1253   2        }
1254   1          else if(strcmp(CMD, "PPH") == 0)
1255   1          {
1256   2          s_cmd = 25;
1257   2        }
1258   1          else if(strcmp(CMD, "SPH") == 0)
1259   1          {
1260   2          s_cmd = 26;
1261   2        }
1262   1          else if(strcmp(CMD, "AUX") == 0)
1263   1          {
1264   2          s_cmd = 27;
1265   2            
1266   2          }
1267   1          else 
1268   1            {
1269   2              s_cmd = 28;
1270   2              commande_valide = 0;
1271   2            }
1272   1        // Cas commande inconnue
1273   1        //else {commande_valide = 0;}
1274   1        
1275   1        //Affichage retour selon si la commande est connue ou non
1276   1        switch(commande_valide){
1277   2          case 0:
1278   2            
1279   2            //Si pas valide : accusé non reception :  CR + LF + #
1280   2          
1281   2            //Send_char(0x0D);
C51 COMPILER V9.59.0.0   MAIN_F0M1                                                         04/13/2021 07:57:16 PAGE 22  

1282   2            //Send_char(0x0A);
1283   2            //Send_char(0x23);
1284   2            break;
1285   2          
1286   2          //valide
1287   2          default: // Si valide : accusé reception :  CR + LF + >
1288   2            Send_char(0x0D);
1289   2            Send_char(0x0A);
1290   2            Send_char(0x3E);
1291   2            break;
1292   2        }
1293   1      }
1294            
1295          
1296          
1297          
1298          //-----------------------------------------------------------------------------
1299          // Sous routine de Reset_buff_ptr
1300          //-----------------------------------------------------------------------------
1301          void Reset_buff_ptr(){
1302   1        
1303   1      // On initialise nos buffers à vide pour être certain de connaitre leur contenu 
1304   1            RX_ptr = &RX_Buf[0]; // On re place le ptr au début.
1305   1            
1306   1            strcpy(CMD, "");
1307   1            ptr_CMD = &CMD[0];
1308   1            
1309   1            strcpy(PARAM_1, "");
1310   1            ptr_PARAM_1 = &PARAM_1[0];
1311   1            
1312   1            strcpy(PARAM_2, "");
1313   1            ptr_PARAM_2 = &PARAM_2[0];
1314   1            
1315   1            strcpy(PARAM_3, "");
1316   1            ptr_PARAM_3 = &PARAM_3[0];
1317   1            
1318   1            strcpy(PARAM_4, "");
1319   1            ptr_PARAM_4 = &PARAM_4[0];
1320   1      
1321   1        }
1322            
1323          //-----------------------------------------------------------------------------
1324          // Struct_init Sous-routine d'analyse de commande
1325          //-----------------------------------------------------------------------------
1326          void Struct_init(void)
1327          {
1328   1        commandes.Etat_Epreuve = Epreuve_non;
1329   1        commandes.Etat_Mouvement = Mouvement_non;
1330   1        
1331   1        commandes.Etat_ACQ_Son = ACQ_non;
1332   1        commandes.Etat_DCT_Obst = DCT_non;
1333   1        commandes.Etat_Lumiere = Lumiere_non;
1334   1        commandes.Etat_Servo = Servo_non;
1335   1        commandes.Etat_Energie = Energie_non;
1336   1        commandes.Etat_Position = Position_non;
1337   1        commandes.Etat_Photo = Photo_non;
1338   1        
1339   1        commandes.V_defaut = 20;
1340   1        
1341   1        
1342   1      }
1343          //-----------------------------------------------------------------------------
C51 COMPILER V9.59.0.0   MAIN_F0M1                                                         04/13/2021 07:57:16 PAGE 23  

1344          // Interrupt Handlers
1345          //-----------------------------------------------------------------------------


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   7751    ----
   CONSTANT SIZE    =    176    ----
   XDATA SIZE       =    222      16
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      2    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
