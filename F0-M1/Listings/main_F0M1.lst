C51 COMPILER V9.59.0.0   MAIN_F0M1                                                         04/27/2021 15:55:32 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE MAIN_F0M1
OBJECT MODULE PLACED IN .\Objects\main_F0M1.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE main_F0M1.c LARGE OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Li
                    -stings\main_F0M1.lst) TABS(2) OBJECT(.\Objects\main_F0M1.obj)

line level    source

   1          //-----------------------------------------------------------------------------
   2          // UART0_Int1.c
   3          //-----------------------------------------------------------------------------
   4          // Copyright 2001 Cygnal Integrated Products, Inc.
   5          //// AUTH: BW// DATE: 28 AUG 01
   6          //// This program configures UART0 to operate in interrupt mode, showing an
   7          // example of a string transmitter and a string receiver.  These strings are
   8          // assumed to be NULL-terminated.
   9          //// Assumes an 22.1184MHz crystal is attached between XTAL1 and XTAL2.
  10          // // The system clock frequency is stored in a global constant SYSCLK.  The
  11          // target UART baud rate is stored in a global constant BAUDRATE.//
  12          // Target: C8051F02x
  13          // Tool chain: KEIL C51 6.03 / KEIL EVAL C51//
  14          //-----------------------------------------------------------------------------
  15          // Includes
  16          //-----------------------------------------------------------------------------
  17          #include <c8051f020.h> // SFR declarations
  18          
  19          #include <stdio.h>
  20          #include <string.h>
  21          #include <stdlib.h>
  22          
  23          #include <FO_M1__Structures_COMMANDES_INFORMATIONS_CentraleDeCommande.h>
  24          //-----------------------------------------------------------------------------
  25          // 16-bit SFR Definitions for ‘F02x
  26          //-----------------------------------------------------------------------------
  27          sfr16 DP       = 0x82;                 
  28          // data pointer
  29          sfr16 TMR3RL   = 0x92;
  30          // Timer3 reload value
  31          sfr16 TMR3     = 0x94;
  32          // Timer3 counter
  33          sfr16 ADC0     = 0xbe;
  34          // ADC0 data
  35          sfr16 ADC0GT   = 0xc4;
  36          // ADC0 greater than window
  37          sfr16 ADC0LT   = 0xc6;
  38          // ADC0 less than window
  39          sfr16 RCAP2    = 0xca;
  40          // Timer2 capture/reload
  41          sfr16 T2       = 0xcc;
  42          // Timer2
  43          sfr16 RCAP4    = 0xe4;
  44          // Timer4 capture/reload
  45          sfr16 T4       = 0xf4;
  46          // Timer4
  47          sfr16 DAC0     = 0xd2;
  48          // DAC0 data
  49          sfr16 DAC1     = 0xd5;
  50          // DAC1 data
  51          
  52          //-----------------------------------------------------------------------------
  53          // Global CONSTANTS
  54          //-----------------------------------------------------------------------------
C51 COMPILER V9.59.0.0   MAIN_F0M1                                                         04/27/2021 15:55:32 PAGE 2   

  55          #define SYSCLK       22118400          
  56          // SYSCLK frequency in Hz
  57          #define BAUDRATE     19200
  58          // Baud rate of UART in bps
  59          
  60          sbit LED = P1^6; // LED = 1 means ON
  61          
  62          struct COMMANDES commandes; //On declare une structure commande
  63          struct INFORMATIONS informations; //On declare une structure information
  64          //-----------------------------------------------------------------------------
  65          // Function PROTOTYPES
  66          //-----------------------------------------------------------------------------
  67          void SYSCLK_Init (void);
  68          void PORT_Init (void);
  69          void UART0_Init (void);
  70          
  71          
  72          
  73          void HQ_CM (void);
  74          void CM_HQ (void);
  75          
  76          void Send_char (char);
  77          void Send_string(char*);
  78          char Recup_char(void);
  79          
  80          char separ_cmd(char*, char*);
  81          void analyse_cmd(void);
  82          void decoup_clef_val(char*, char*, char*);
  83          
  84          void Reset_buff_ptr(void);
  85          void Struct_init(void);
  86          
  87          //-----------------------------------------------------------------------------
  88          // Global VARIABLES
  89          //-----------------------------------------------------------------------------
  90          bit TX_Ready;
  91          // ‘1’ means okay to TX
  92          char *TX_ptr;
  93          // pointer to string to transmit
  94          bit RX_Ready;
  95          // ‘1’ means RX string received
  96          
  97          char RX_Buf[50]="";
  98          char* RX_ptr=&RX_Buf[0];
  99          // receive string storage buffer
 100          
 101          char CMD[15]=""; // Buffer de sauvegarde de la commande
 102          char* ptr_CMD = &CMD[0];
 103          
 104          char PARAM_1[10]=""; // Buffer de sauvegarde des param 1
 105          char* ptr_PARAM_1 = &PARAM_1[0];
 106          
 107          char PARAM_2[10]=""; // Buffer de sauvegarde des param 2
 108          char* ptr_PARAM_2 = &PARAM_2[0];
 109          
 110          char PARAM_3[10]=""; // Buffer de sauvegarde des param 3
 111          char* ptr_PARAM_3 = &PARAM_3[0];
 112          
 113          char PARAM_4[10]=""; // Buffer de sauvegarde des param 4
 114          char* ptr_PARAM_4 = &PARAM_4[0];
 115          
 116          
C51 COMPILER V9.59.0.0   MAIN_F0M1                                                         04/27/2021 15:55:32 PAGE 3   

 117          
 118          char buf_clef[15];
 119          char buf_val[15];
 120          
 121          char test[5];
 122          
 123          int nb_cmd;
 124          int s_cmd;
 125          int commande_valide;
 126          
 127          
 128          //-----------------------------------------------------------------------------
 129          // MAIN Routine
 130          //-----------------------------------------------------------------------------
 131          void main (void) {
 132   1      
 133   1        WDTCN = 0xde; // disable watchdog timer
 134   1        WDTCN = 0xad;
 135   1        
 136   1        SYSCLK_Init(); // initialize oscillator
 137   1        PORT_Init (); // initialize crossbar and GPIO   
 138   1        UART0_Init (); // initialize UART0   
 139   1        
 140   1        Struct_init(); //Init des valeurs de la struct
 141   1        
 142   1        Send_string("Tapez une cmd ");
 143   1      
 144   1        while (1){
 145   2            if(RI0 == 1)
 146   2              {
 147   3                HQ_CM();
 148   3              }
 149   2            CM_HQ();  
 150   2          }
 151   1      }
 152          
 153          
 154          //-----------------------------------------------------------------------------
 155          // Initialization Subroutines
 156          //-----------------------------------------------------------------------------
 157          // Sous routines d'initialisation du système de réception
 158          //-----------------------------------------------------------------------------
 159          // SYSCLK_Init
 160          //-----------------------------------------------------------------------------//
 161          // This routine initializes the system clock to use an 22.1184MHz crystal
 162          // as its clock source.
 163          //
 164          void SYSCLK_Init (void){
 165   1        int i;
 166   1        // delay counter
 167   1        OSCXCN = 0x67;
 168   1        // start external oscillator with
 169   1        // 22.1184MHz crystal
 170   1        for (i=0; i < 256; i++) ;
 171   1        // wait for XTLVLD to stabilize
 172   1        while (!(OSCXCN & 0x80)) ;
 173   1        // Wait for crystal osc. to settle
 174   1        OSCICN = 0x88;
 175   1        // select external oscillator as SYSCLK
 176   1        // source and enable missing clock
 177   1        // detector
 178   1        }
C51 COMPILER V9.59.0.0   MAIN_F0M1                                                         04/27/2021 15:55:32 PAGE 4   

 179          //-----------------------------------------------------------------------------
 180          // PORT_Init Configure the Crossbar and GPIO ports
 181          //-----------------------------------------------------------------------------
 182          void PORT_Init (void){
 183   1          XBR0    |= 0x04;
 184   1          // Enable UART0
 185   1          XBR2    |= 0x64;
 186   1          // Enable crossbar and weak pull-ups  
 187   1          P0MDOUT |= 0x01;
 188   1          // enable TX0 as a push-pull output  
 189   1          
 190   1          }
 191          //-----------------------------------------------------------------------------
 192          // UART0_Init  Configure the UART0 using Timer1, for <baudrate> and 8-N-1.
 193          //-----------------------------------------------------------------------------
 194          void UART0_Init (void){
 195   1            SCON0  = 0x50; // SCON0: mode 1, 8-bit UART, enable RX
 196   1            TMOD   = 0x20; // TMOD: timer 1, mode 2, 8-bit reload 
 197   1            TH1    = -(SYSCLK/BAUDRATE/16); // set Timer1 reload value for baudrate
 198   1            TR1    = 1; // start Timer1
 199   1            CKCON |= 0x10; // Timer1 uses SYSCLK as time base
 200   1            PCON  |= 0x80; // SMOD00 = 1
 201   1            //ES0    = 1; // enable UART0 interrupts
 202   1            //TX_Ready = 1; // indicate TX ready for transmit 
 203   1            //RX_Ready = 0; // indicate RX string not ready
 204   1            //TX_ptr = NULL;
 205   1      }
 206              
 207          
 208          //-----------------------------------------------------------------------------
 209          // HQ_CM Sous-routine d'écriture de Commande 
 210          //-----------------------------------------------------------------------------
 211          void HQ_CM(void)
 212            {
 213   1          char char_unique;
 214   1          
 215   1          char_unique = Recup_char(); // On récupère le caractère reçu.
 216   1          
 217   1          *RX_ptr = char_unique; // On stocke ds le buffer tout les caractères.
 218   1          *(RX_ptr + 1) = '\0';
 219   1          RX_ptr++;
 220   1          
 221   1          Send_char(char_unique); // On le renvoie pour savoir ce qu'on a tapé
 222   1          
 223   1          
 224   1          if (char_unique == '\r')
 225   1          {
 226   2            Send_char('\n'); // retour à la ligne
 227   2            
 228   2            Reset_buff_ptr(); // On initialise nos buffers à vide pour être certain de connaitre leur contenu
 229   2            
 230   2            // On commence à séparer le contenu de RX_Buf en sous buffers appropriés.
 231   2            separ_cmd(RX_ptr , ptr_CMD );
 232   2            
 233   2            if(separ_cmd(RX_ptr , ptr_PARAM_1)!=-1)
 234   2            {
 235   3              nb_cmd=0;
 236   3            }
 237   2            
 238   2            if(separ_cmd(RX_ptr , ptr_PARAM_2)!=-1)
 239   2            {
 240   3              nb_cmd=1;
C51 COMPILER V9.59.0.0   MAIN_F0M1                                                         04/27/2021 15:55:32 PAGE 5   

 241   3            }
 242   2            
 243   2            if(separ_cmd(RX_ptr , ptr_PARAM_3)!=-1)
 244   2            {
 245   3              nb_cmd=2;
 246   3            }
 247   2            
 248   2            if(separ_cmd(RX_ptr , ptr_PARAM_4)!=-1)
 249   2            {
 250   3              nb_cmd=3;
 251   3            }
 252   2            else nb_cmd=4;
 253   2            
 254   2      
 255   2            
 256   2            
 257   2            analyse_cmd();
 258   2            
 259   2            
 260   2            switch(s_cmd)
 261   2            {     // Int or Enum type !
 262   3            
 263   3              
 264   3            case 0: 
 265   3              Send_string("Cas 0");
 266   3              break;
 267   3            
 268   3            
 269   3            case 1:
 270   3              Send_string("D");
 271   3              if(nb_cmd == 0)
 272   3                {
 273   4                  commandes.Etat_Epreuve = 1;
 274   4                }
 275   3              else //Un argument : le n° de l'epreuve
 276   3                {
 277   4                  if(0<atoi(PARAM_1) && 9>atoi(PARAM_1))
 278   4                    {
 279   5                      commandes.Etat_Epreuve = atoi(PARAM_1); 
 280   5                    }
 281   4          //Sinon commande invalide
 282   4              else
 283   4                  {
 284   5                    commande_valide = 0;
 285   5                  }
 286   4                }
 287   3              break;
 288   3            
 289   3            case 2:
 290   3              Send_string("E");
 291   3            commandes.Etat_Epreuve = 9;
 292   3              break;
 293   3            
 294   3            case 3:
 295   3              Send_string("Q");
 296   3            commandes.Etat_Epreuve = 10;
 297   3              break;
 298   3            
 299   3            case 4:
 300   3              Send_string("TV");
 301   3              if(nb_cmd == 1)
 302   3                {
C51 COMPILER V9.59.0.0   MAIN_F0M1                                                         04/27/2021 15:55:32 PAGE 6   

 303   4                  if(5>atoi(PARAM_1) && 101>atoi(PARAM_1))
 304   4                    {
 305   5                      commandes.V_defaut = atoi(PARAM_1);
 306   5                    }
 307   4                }
 308   3              else
 309   3                  {
 310   4                    commande_valide = 0;
 311   4                  }
 312   3              break;
 313   3            
 314   3            case 5:
 315   3              Send_string("A");
 316   3              if(nb_cmd == 0)
 317   3                {
 318   4                  commandes.Vitesse = commandes.V_defaut;
 319   4                  commandes.Etat_Mouvement = Avancer;
 320   4                }
 321   3          else
 322   3          {
 323   4            if(5>atoi(PARAM_1) && 101>atoi(PARAM_1))
 324   4            {
 325   5              commandes.Vitesse = atoi(PARAM_1);
 326   5              commandes.Etat_Mouvement = Avancer;
 327   5            }
 328   4            else
 329   4            {
 330   5              commande_valide = 0;
 331   5            }
 332   4          }
 333   3              break;
 334   3            
 335   3            case 6:
 336   3              Send_string("B");
 337   3              if(nb_cmd == 0)
 338   3          {
 339   4            commandes.Vitesse = commandes.V_defaut;
 340   4            commandes.Etat_Mouvement = Reculer;
 341   4          }
 342   3          else
 343   3          {
 344   4            if(5>atoi(PARAM_1) && 101>atoi(PARAM_1))
 345   4            {
 346   5              commandes.Vitesse = atoi(PARAM_1);
 347   5              commandes.Etat_Mouvement = Reculer;
 348   5            }
 349   4            else
 350   4            {
 351   5              commande_valide = 0;
 352   5            }
 353   4          }
 354   3              break;
 355   3            
 356   3            case 7:
 357   3              Send_string("S");
 358   3              commandes.Etat_Mouvement = Stopper;
 359   3              break;
 360   3            
 361   3            case 8:
 362   3              Send_string("RD");
 363   3              commandes.Etat_Mouvement = Rot_90D;
 364   3              break;
C51 COMPILER V9.59.0.0   MAIN_F0M1                                                         04/27/2021 15:55:32 PAGE 7   

 365   3            
 366   3            case 9:
 367   3              Send_string("RG");
 368   3              commandes.Etat_Mouvement = Rot_90G;
 369   3              
 370   3              break;
 371   3            
 372   3            case 10:
 373   3              Send_string("RC");
 374   3              if(nb_cmd == 0)
 375   3                {
 376   4                  commande_valide = 0;
 377   4                }
 378   3        
 379   3                else
 380   3                  {
 381   4                    if(strcmp(PARAM_1, "D") == 0)
 382   4                      {
 383   5                        commandes.Etat_Mouvement = Rot_180D;
 384   5      
 385   5                      }
 386   4                    else if(strcmp(PARAM_1, "G") == 0)
 387   4                        {
 388   5                          commandes.Etat_Mouvement = Rot_180G;
 389   5                        }
 390   4                    else{
 391   5                          commande_valide = 0;
 392   5                        }
 393   4                  }
 394   3          
 395   3              break;
 396   3            
 397   3            case 11:
 398   3              Send_string("RA");
 399   3            
 400   3              if(nb_cmd == 0)
 401   3                {
 402   4                  commandes.Etat_Mouvement = Rot_AngD;
 403   4                  commandes.Angle = 90;
 404   4                }
 405   3        
 406   3        
 407   3              else
 408   3                { 
 409   4                  decoup_clef_val(PARAM_1, buf_clef, buf_val);
 410   4            //Si droite et ecrit correctement
 411   4                  if(strcmp(buf_clef, "D") == 0 &&
 412   4                    atoi(buf_val) > 0 &&
 413   4                    atoi(buf_val) < 181)
 414   4                  {
 415   5                    commandes.Etat_Mouvement = Rot_AngD;
 416   5                    commandes.Angle = atoi(buf_val);
 417   5            }
 418   4            else if(strcmp(buf_clef, "G") == 0 && atoi(buf_val) > 0 && atoi(buf_val) < 181)
 419   4              {
 420   5                commandes.Etat_Mouvement = Rot_AngG;
 421   5                commandes.Angle = atoi(buf_val);
 422   5              }
 423   4            else{
 424   5              commande_valide = 0;
 425   5            }
 426   4          }
C51 COMPILER V9.59.0.0   MAIN_F0M1                                                         04/27/2021 15:55:32 PAGE 8   

 427   3              break;
 428   3            
 429   3            case 12:
 430   3              Send_string("G");
 431   3            
 432   3              if(nb_cmd != 3)
 433   3                {
 434   4                  commande_valide = 0;
 435   4                }
 436   3              else 
 437   3                {
 438   4                
 439   4                  decoup_clef_val(PARAM_1, buf_clef, buf_val);
 440   4      
 441   4                  if((strcmp(buf_clef, "X") == 0) && ((-100 < atoi(buf_val)) && (100 > atoi(buf_val))))
 442   4                    {
 443   5                      commandes.Etat_Mouvement = Depl_Coord;
 444   5                      commandes.Coord_X = atoi(buf_val);
 445   5                    }
 446   4      
 447   4                  else if((strcmp(buf_clef, "Y") == 0) && ((-100 < atoi(buf_val)) && (100 > atoi(buf_val))) && command
             -e_valide != 0)
 448   4                    {
 449   5                      commandes.Coord_Y = atoi(buf_val);
 450   5                    }
 451   4      
 452   4                  else if((strcmp(buf_clef, "A") == 0) && ((-181 < atoi(buf_val)) && (181 > atoi(buf_val))) && command
             -e_valide != 0)
 453   4                    {
 454   5                      commandes.Angle = atoi(buf_val);
 455   5                    }
 456   4      
 457   4                  else
 458   4                    {
 459   5                      commande_valide = 0;
 460   5                    }
 461   4          
 462   4        
 463   4                  decoup_clef_val(PARAM_2, buf_clef, buf_val);
 464   4      
 465   4                  if((strcmp(buf_clef, "Y") == 0) && ((-100 < atoi(buf_val)) && (100 > atoi(buf_val))))
 466   4                    {
 467   5                      commandes.Coord_X = atoi(buf_val);
 468   5                    }
 469   4      
 470   4                  else if((strcmp(buf_clef, "X") == 0) && ((-100 < atoi(buf_val)) && (100 > atoi(buf_val))) && command
             -e_valide != 0)
 471   4                    {
 472   5                      commandes.Coord_Y = atoi(buf_val);
 473   5                    }
 474   4      
 475   4                  else if((strcmp(buf_clef, "A") == 0) && ((-181 < atoi(buf_val)) && (181 > atoi(buf_val))) && command
             -e_valide != 0)
 476   4                    {
 477   5                      commandes.Angle = atoi(buf_val);
 478   5                    }
 479   4      
 480   4                  else
 481   4                    {
 482   5                      commande_valide = 0;
 483   5                    }
 484   4          
C51 COMPILER V9.59.0.0   MAIN_F0M1                                                         04/27/2021 15:55:32 PAGE 9   

 485   4                  
 486   4                  decoup_clef_val(PARAM_3, buf_clef, buf_val);
 487   4      
 488   4                  if((strcmp(buf_clef, "A") == 0) && ((-181 < atoi(buf_val)) && (181 > atoi(buf_val))) && commande_val
             -ide != 0)
 489   4                  {
 490   5                    commandes.Angle = atoi(buf_val);
 491   5                  }
 492   4      
 493   4                  else if((strcmp(buf_clef, "Y") == 0) && ((-100 < atoi(buf_val)) && (100 > atoi(buf_val))))
 494   4                    {
 495   5                      commandes.Coord_X = atoi(buf_val);
 496   5                    }
 497   4      
 498   4                  else if((strcmp(buf_clef, "X") == 0) && ((-100 < atoi(buf_val)) && (100 > atoi(buf_val))) && command
             -e_valide != 0)
 499   4                    {
 500   5                      commandes.Coord_Y = atoi(buf_val);
 501   5                    }
 502   4      
 503   4                  else
 504   4                    {
 505   5                      commande_valide = 0;
 506   5                    }
 507   4          //Si un des arguments est invalide, on remet tout a 0
 508   4                  if(commande_valide == 0)
 509   4                    {
 510   5                      commandes.Etat_Mouvement = Mouvement_non;
 511   5                      commandes.Coord_X = 0;
 512   5                      commandes.Coord_Y = 0;
 513   5                      commandes.Angle = 0;
 514   5                    }
 515   4                }
 516   3              break;
 517   3            
 518   3            case 13:
 519   3              Send_string("ASS");
 520   3              if(nb_cmd == 0)
 521   3                {
 522   4                  commande_valide = 0;
 523   4                }
 524   3        
 525   3              if(atoi(PARAM_1) > 0 && atoi(PARAM_1) < 99)
 526   3                {
 527   4                  commandes.ACQ_Duree = atoi(PARAM_1);
 528   4                  commandes.Etat_ACQ_Son = ACQ_oui;
 529   4                }
 530   3              else
 531   3                {
 532   4                  commande_valide = 0;
 533   4                }
 534   3              break;
 535   3            
 536   3            case 14: // Mesure conso courant pas encore implémenté
 537   3              Send_string("MI");
 538   3              commandes.Etat_Energie = Mesure_I;
 539   3              break;
 540   3            
 541   3            case 15: // Mesure conso energie pas encore implémenté
 542   3              Send_string("ME");
 543   3              commandes.Etat_Energie = Mesure_E;
 544   3              break;
C51 COMPILER V9.59.0.0   MAIN_F0M1                                                         04/27/2021 15:55:32 PAGE 10  

 545   3            
 546   3            case 16:
 547   3              Send_string("IPO");
 548   3            
 549   3              if(nb_cmd != 3)
 550   3                {
 551   4                  commande_valide = 0;
 552   4                }
 553   3              else 
 554   3                {
 555   4                  decoup_clef_val(PARAM_1, buf_clef, buf_val);
 556   4                  if((strcmp(buf_clef, "X") == 0) && ((-100 < atoi(buf_val)) && (100 > atoi(buf_val))))
 557   4                    {
 558   5                      commandes.Etat_Position = Init_Position;
 559   5                      commandes.Pos_Coord_X = atoi(buf_val);
 560   5                    }
 561   4      
 562   4              else if((strcmp(buf_clef, "Y") == 0) && ((-100 < atoi(buf_val)) && (100 > atoi(buf_val))) && comma
             -nde_valide != 0)
 563   4              {
 564   5                commandes.Pos_Coord_Y = atoi(buf_val);
 565   5              }
 566   4      
 567   4              else if((strcmp(buf_clef, "A") == 0) && ((-181 < atoi(buf_val)) && (181 > atoi(buf_val))) && comma
             -nde_valide != 0)
 568   4              {
 569   5                commandes.Pos_Angle = atoi(buf_val);
 570   5              }
 571   4      
 572   4              else
 573   4                {
 574   5                  commande_valide = 0;
 575   5                }
 576   4          
 577   4          //Deuxieme argument si le premier est fait
 578   4          decoup_clef_val(PARAM_2, buf_clef, buf_val);
 579   4      
 580   4          if((strcmp(buf_clef, "Y") == 0) && ((-100 < atoi(buf_val)) && (100 > atoi(buf_val))))
 581   4            {
 582   5              commandes.Pos_Coord_X = atoi(buf_val);
 583   5            }
 584   4      
 585   4              else if((strcmp(buf_clef, "X") == 0) && ((-100 < atoi(buf_val)) && (100 > atoi(buf_val))) && comma
             -nde_valide != 0)
 586   4              {
 587   5                commandes.Pos_Coord_Y = atoi(buf_val);
 588   5              }
 589   4      
 590   4              else if((strcmp(buf_clef, "A") == 0) && ((-181 < atoi(buf_val)) && (181 > atoi(buf_val))) && comma
             -nde_valide != 0)
 591   4              {
 592   5                commandes.Pos_Angle = atoi(buf_val);
 593   5              }
 594   4      
 595   4          else
 596   4            {
 597   5              commande_valide = 0;
 598   5            }
 599   4          
 600   4          //Troisieme argument
 601   4          decoup_clef_val(PARAM_3, buf_clef, buf_val);
 602   4      
C51 COMPILER V9.59.0.0   MAIN_F0M1                                                         04/27/2021 15:55:32 PAGE 11  

 603   4          if((strcmp(buf_clef, "A") == 0) && ((-181 < atoi(buf_val)) && (181 > atoi(buf_val))) && commande_valide 
             -!= 0)
 604   4            {
 605   5              commandes.Pos_Angle = atoi(buf_val);
 606   5            }
 607   4      
 608   4          else if((strcmp(buf_clef, "Y") == 0) && ((-100 < atoi(buf_val)) && (100 > atoi(buf_val))))
 609   4            {
 610   5              commandes.Pos_Coord_X = atoi(buf_val);
 611   5            }
 612   4      
 613   4          else if((strcmp(buf_clef, "X") == 0) && ((-100 < atoi(buf_val)) && (100 > atoi(buf_val))) && commande_
             -valide != 0)
 614   4          {
 615   5            commandes.Pos_Coord_Y = atoi(buf_val);
 616   5          }
 617   4      
 618   4          else
 619   4            {
 620   5              commande_valide = 0;
 621   5            }
 622   4          }
 623   3          
 624   3          if(commande_valide == 0)
 625   3            {
 626   4              commandes.Etat_Mouvement = Mouvement_non;
 627   4              commandes.Pos_Coord_X = 0;
 628   4              commandes.Pos_Coord_Y = 0;
 629   4              commandes.Pos_Angle = 0;
 630   4            }
 631   3            
 632   3              break;
 633   3            
 634   3            case 17:
 635   3              Send_string("POS");
 636   3              commandes.Etat_Position = Demande_Position;
 637   3              break;
 638   3            
 639   3            case 18:
 640   3              test[0] = 'M';
 641   3              test[1] = 'O';
 642   3              test[2] = 'U';
 643   3              test[3] = '\r';
 644   3              break;
 645   3            
 646   3            case 19:
 647   3              Send_string("MOB");
 648   3            
 649   3              switch (nb_cmd)
 650   3                {
 651   4                
 652   4                  case 0:
 653   4                    commandes.Etat_DCT_Obst = oui_360;
 654   4                    commandes.DCT_Obst_Resolution = 30;
 655   4                    break;
 656   4      
 657   4              
 658   4                  case 1:
 659   4                  
 660   4                    if(strcmp(PARAM_1, "D") == 0)
 661   4                      {
 662   5                        commandes.Etat_DCT_Obst = oui_180;
C51 COMPILER V9.59.0.0   MAIN_F0M1                                                         04/27/2021 15:55:32 PAGE 12  

 663   5                      }
 664   4       
 665   4                    else
 666   4                      {
 667   5                        decoup_clef_val(PARAM_1, buf_clef, buf_val);
 668   5                        if(strcmp(buf_clef, "A") == 0 && atoi(buf_val) > 4 && atoi(buf_val) < 46)
 669   5                          {
 670   6                            commandes.DCT_Obst_Resolution = atoi(buf_val);
 671   6                          }
 672   5                      }
 673   4                    break;
 674   4      
 675   4         
 676   4                  case 2:
 677   4                    if(strcmp(PARAM_1, "D") == 0)
 678   4                      {
 679   5                        commandes.Etat_DCT_Obst = oui_180;
 680   5                      }
 681   4       
 682   4      
 683   4                    
 684   4                        decoup_clef_val(PARAM_2, buf_clef, buf_val);
 685   4                        if(strcmp(buf_clef, "A") == 0 && atoi(buf_val) > 4 && atoi(buf_val) < 46)
 686   4                          {
 687   5                            commandes.DCT_Obst_Resolution = atoi(buf_val);
 688   5                          }
 689   4                              
 690   4             
 691   4                        else
 692   4                          {
 693   5                            commande_valide = 0;
 694   5                          }
 695   4                    break;
 696   4       
 697   4                  default:
 698   4                    commande_valide = 0;
 699   4                    break;
 700   4                }
 701   3              break;
 702   3            
 703   3            case 20: // FONCTION NON PROGRAMMEE POUR LE MOMENT  
 704   3              test[0] = 'M';
 705   3              test[1] = 'O';
 706   3              test[2] = 'S';
 707   3              test[3] = '\r';
 708   3              break;
 709   3            
 710   3            case 21: // FONCTION NON PROGRAMMEE POUR LE MOMENT
 711   3              test[0] = 'S';
 712   3              test[1] = 'D';
 713   3              test[2] = '\r';
 714   3              break;
 715   3            
 716   3            case 22:
 717   3              Send_string("L");
 718   3            
 719   3              commandes.Etat_Lumiere = Allumer;
 720   3              commandes.Lumiere_Intensite = 100;
 721   3              commandes.Lumiere_Duree = 99;
 722   3              commandes.Lumire_Extinction = 0;
 723   3              commandes.Lumiere_Nbre = 1;
 724   3      
C51 COMPILER V9.59.0.0   MAIN_F0M1                                                         04/27/2021 15:55:32 PAGE 13  

 725   3              if(nb_cmd != 0)
 726   3                {
 727   4                  decoup_clef_val(PARAM_1, buf_clef, buf_val);
 728   4                  if(strcmp(buf_clef, "I") == 0 && 0 < atoi(buf_val) && 101 > atoi(buf_val))
 729   4                    {
 730   5                      commandes.Lumiere_Intensite = atoi(buf_val);
 731   5                    }
 732   4                  else if(strcmp(buf_clef, "D") == 0 && 0 < atoi(buf_val) && 100 > atoi(buf_val))
 733   4                  {
 734   5                      commandes.Lumiere_Duree = atoi(buf_val);
 735   5                  }
 736   4                  else if(strcmp(buf_clef, "E") == 0 && 0 <= atoi(buf_val) && 100 > atoi(buf_val))
 737   4                  {
 738   5                      commandes.Lumire_Extinction = atoi(buf_val);
 739   5                  }
 740   4                  else if (strcmp(buf_clef, "N") == 0 &&
 741   4                  0 < atoi(buf_val) &&
 742   4                  100 > atoi(buf_val)){
 743   5                      commandes.Lumiere_Nbre = atoi(buf_val);
 744   5              }
 745   4              else{
 746   5                  commande_valide = 0;
 747   5              }
 748   4      
 749   4              decoup_clef_val(PARAM_2, buf_clef, buf_val);
 750   4              if(strcmp(buf_clef, "I") == 0 &&
 751   4                  0 < atoi(buf_val) &&
 752   4                  101 > atoi(buf_val)){
 753   5                      commandes.Lumiere_Intensite = atoi(buf_val);
 754   5              }
 755   4              else if(strcmp(buf_clef, "D") == 0 &&
 756   4                  0 < atoi(buf_val) &&
 757   4                  100 > atoi(buf_val)){
 758   5                      commandes.Lumiere_Duree = atoi(buf_val);
 759   5              }
 760   4              else if(strcmp(buf_clef, "E") == 0 &&
 761   4                  0 <= atoi(buf_val) &&
 762   4                  100 > atoi(buf_val)){
 763   5                      commandes.Lumire_Extinction = atoi(buf_val);
 764   5              }
 765   4              else if (strcmp(buf_clef, "N") == 0 &&
 766   4                  0 < atoi(buf_val) &&
 767   4                  100 > atoi(buf_val)){
 768   5                      commandes.Lumiere_Nbre = atoi(buf_val);
 769   5              }
 770   4              else{
 771   5                  commande_valide = 0;
 772   5              }
 773   4      
 774   4              decoup_clef_val(PARAM_3, buf_clef, buf_val);
 775   4              if(strcmp(buf_clef, "I") == 0 &&
 776   4                  0 < atoi(buf_val) &&
 777   4                  101 > atoi(buf_val)){
 778   5                      commandes.Lumiere_Intensite = atoi(buf_val);
 779   5              }
 780   4              else if(strcmp(buf_clef, "D") == 0 &&
 781   4                  0 < atoi(buf_val) &&
 782   4                  100 > atoi(buf_val)){
 783   5                      commandes.Lumiere_Duree = atoi(buf_val);
 784   5              }
 785   4              else if(strcmp(buf_clef, "E") == 0 &&
 786   4                  0 <= atoi(buf_val) &&
C51 COMPILER V9.59.0.0   MAIN_F0M1                                                         04/27/2021 15:55:32 PAGE 14  

 787   4                  100 > atoi(buf_val)){
 788   5                      commandes.Lumire_Extinction = atoi(buf_val);
 789   5              }
 790   4              else if (strcmp(buf_clef, "N") == 0 &&
 791   4                  0 < atoi(buf_val) &&
 792   4                  100 > atoi(buf_val)){
 793   5                      commandes.Lumiere_Nbre = atoi(buf_val);
 794   5              }
 795   4              else{
 796   5                  commande_valide = 0;
 797   5              }
 798   4      
 799   4              decoup_clef_val(PARAM_4, buf_clef, buf_val);
 800   4              if(strcmp(buf_clef, "I") == 0 &&
 801   4                  0 < atoi(buf_val) &&
 802   4                  101 > atoi(buf_val)){
 803   5                      commandes.Lumiere_Intensite = atoi(buf_val);
 804   5              }
 805   4              else if(strcmp(buf_clef, "D") == 0 &&
 806   4                  0 < atoi(buf_val) &&
 807   4                  100 > atoi(buf_val)){
 808   5                      commandes.Lumiere_Duree = atoi(buf_val);
 809   5              }
 810   4              else if(strcmp(buf_clef, "E") == 0 &&
 811   4                  0 <= atoi(buf_val) &&
 812   4                  100 > atoi(buf_val)){
 813   5                      commandes.Lumire_Extinction = atoi(buf_val);
 814   5              }
 815   4              else if (strcmp(buf_clef, "N") == 0 &&
 816   4                  0 < atoi(buf_val) &&
 817   4                  100 > atoi(buf_val)){
 818   5                      commandes.Lumiere_Nbre = atoi(buf_val);
 819   5              }
 820   4              else{
 821   5                  commande_valide = 0;
 822   5              }
 823   4          }
 824   3      
 825   3          if(commande_valide == 0){
 826   4              commandes.Etat_Lumiere = Lumiere_non;
 827   4          }
 828   3              
 829   3              break;
 830   3            
 831   3            case 23:
 832   3              Send_string("LS");
 833   3              commandes.Etat_Lumiere = Eteindre;
 834   3              break;
 835   3            
 836   3            case 24:
 837   3              Send_string("CS");
 838   3            
 839   3              switch(nb_cmd)
 840   3            {
 841   4              case 0:
 842   4                  commandes.Etat_Servo = Servo_H;
 843   4                  commandes.Servo_Angle = 0;
 844   4                  break;
 845   4              case 1:
 846   4                  
 847   4                      decoup_clef_val(PARAM_1, buf_clef, buf_val);
 848   4                      if(strcmp(buf_clef, "A") == 0 && -100 < atoi(buf_val) && 100 > atoi(buf_val))
C51 COMPILER V9.59.0.0   MAIN_F0M1                                                         04/27/2021 15:55:32 PAGE 15  

 849   4                      {
 850   5                        commandes.Servo_Angle = atoi(buf_val);
 851   5                      }
 852   4                      else
 853   4                        {
 854   5                          commande_valide = 0;
 855   5                        }
 856   4                  
 857   4                      if (strcmp(PARAM_1, "H") == 0)
 858   4                        {
 859   5                          commandes.Etat_Servo = Servo_H;
 860   5                        }
 861   4                  else if (strcmp(PARAM_1, "V") == 0)
 862   4                    {
 863   5                      commandes.Etat_Servo = Servo_V;
 864   5                    }
 865   4                  else
 866   4                    {
 867   5                      commande_valide = 0;
 868   5                    }
 869   4                  break;
 870   4      
 871   4              case 2:
 872   4                  
 873   4                      decoup_clef_val(PARAM_2, buf_clef, buf_val);
 874   4                      if(strcmp(buf_clef, "A") == 0 && -100 < atoi(buf_val) && 100 > atoi(buf_val))
 875   4                        {
 876   5                          commandes.Servo_Angle = atoi(buf_val);
 877   5                        }
 878   4                      else
 879   4                        {
 880   5                          commande_valide = 0;
 881   5                        }
 882   4                  
 883   4                  if (strcmp(PARAM_1, "H") == 0)
 884   4                    {
 885   5                      commandes.Etat_Servo = Servo_H;
 886   5                    }
 887   4                  else if (strcmp(PARAM_1, "V") == 0)
 888   4                    {
 889   5                      commandes.Etat_Servo = Servo_V;
 890   5                    }
 891   4                  else
 892   4                    {
 893   5                      commande_valide = 0;
 894   5                    }
 895   4                  break;
 896   4      
 897   4                  default:
 898   4                      commande_valide = 0;
 899   4                      break;
 900   4          }
 901   3      
 902   3          if(commande_valide == 0)
 903   3            {
 904   4              commandes.Etat_Servo = Servo_non;
 905   4              commandes.Servo_Angle = 0;
 906   4            }
 907   3              break;
 908   3            
 909   3            case 25:
 910   3              Send_string("PPH");
C51 COMPILER V9.59.0.0   MAIN_F0M1                                                         04/27/2021 15:55:32 PAGE 16  

 911   3            
 912   3              commandes.Etat_Photo = Photo_non;
 913   3              commandes.Photo_Duree = 1;
 914   3              commandes.Photo_Nbre = 1;
 915   3      
 916   3                if(strcmp(PARAM_1, "O") == 0)
 917   3                  {
 918   4                    commandes.Etat_Photo = Photo_1;
 919   4                  }
 920   3      
 921   3                else if(strcmp(PARAM_1, "C") == 0)
 922   3                  {
 923   4                    commandes.Etat_Photo = Photo_continue;
 924   4                  }
 925   3      
 926   3                else if(strcmp(PARAM_1, "S") == 0)
 927   3                  {
 928   4                    commandes.Etat_Photo = Photo_Multiple;
 929   4                  }
 930   3      
 931   3                else
 932   3                  {
 933   4                    commande_valide = 0;
 934   4                  }
 935   3                decoup_clef_val(PARAM_2, buf_clef, buf_val);
 936   3                if(strcmp(buf_clef, "E") == 0 && 0 <= atoi(buf_val) && 100 > atoi(buf_val))
 937   3                      {
 938   4                        commandes.Photo_Duree = atoi(buf_val);
 939   4                      }
 940   3                else
 941   3                  {
 942   4                    commande_valide = 0;
 943   4                  }
 944   3      
 945   3            
 946   3                decoup_clef_val(PARAM_3, buf_clef, buf_val);
 947   3                if(strcmp(buf_clef, "N") == 0 && 0 < atoi(buf_val) && 256 > atoi(buf_val))
 948   3                {
 949   4                      commandes.Photo_Nbre = atoi(buf_val);
 950   4                }
 951   3                else
 952   3                  {
 953   4                    commande_valide = 0;
 954   4                  }
 955   3              
 956   3        
 957   3      
 958   3          if(commande_valide == 0)
 959   3            {
 960   4              commandes.Etat_Photo = Photo_non;
 961   4              commandes.Photo_Duree = 1;
 962   4              commandes.Photo_Nbre = 1;
 963   4            }
 964   3              
 965   3              break;
 966   3            
 967   3            case 26:
 968   3              Send_string("SPH");
 969   3              commandes.Etat_Photo = Photo_stop;
 970   3              break;
 971   3            
 972   3            case 27:
C51 COMPILER V9.59.0.0   MAIN_F0M1                                                         04/27/2021 15:55:32 PAGE 17  

 973   3              test[0] = 'A';
 974   3              test[1] = 'U';
 975   3              test[2] = 'X';
 976   3              test[3] = '\r';
 977   3            
 978   3            default:
 979   3              Send_char(0x0D);
 980   3              Send_char(0x0A);
 981   3              Send_char(0x23);
 982   3              break;
 983   3              
 984   3            }
 985   2            Reset_buff_ptr();
 986   2            RX_ptr = &RX_Buf[0]; // On re place le ptr au début. Pour être capable de relancer un cycle.
 987   2          }
 988   1        }
 989            
 990            
 991          //-----------------------------------------------------------------------------
 992          // CM_HQ Sous-routine de retour d'Information
 993          //-----------------------------------------------------------------------------
 994          void CM_HQ(void)
 995            {
 996   1          if(informations.Etat_Invite == Invite_oui){
 997   2              Send_string(informations.MSG_Invit);
 998   2          }
 999   1          //
1000   1          if(informations.Etat_BUT_Mouvement == BUT_Atteint_oui){
1001   2              Send_string("Coordonnees atteintes");
1002   2          }
1003   1          //
1004   1          if(informations.Etat_BUT_Servo == BUT_Servo_H){
1005   2              Send_string("Servo H en place");
1006   2          }
1007   1          else if(informations.Etat_BUT_Servo == BUT_Servo_V){
1008   2              Send_string("Servo V en place");
1009   2          }
1010   1          //
1011   1          if(informations.Etat_DCT_Obst == BUT_Atteint_oui){
1012   2              Send_string("Coordonnees atteintes");
1013   2          }
1014   1          //
1015   1          if(informations.Etat_RESULT_Courant == BUT_Atteint_oui){
1016   2              Send_string("Coordonnees atteintes");
1017   2          }
1018   1          //
1019   1          if(informations.Etat_RESULT_Energie == BUT_Atteint_oui){
1020   2              Send_string("Coordonnees atteintes");
1021   2          }
1022   1          //
1023   1          if(informations.Etat_RESULT_Position == BUT_Atteint_oui){
1024   2              Send_string("Coordonnees atteintes");
1025   2          }
1026   1          //
1027   1          if(informations.Etat_Aux == Aux_oui){
1028   2              Send_string(informations.MSG_Aux);
1029   2          }
1030   1        }
1031          //-----------------------------------------------------------------------------
1032          // send_char et Send_string Sous-routines pour envoyer un char et string
1033          //-----------------------------------------------------------------------------
1034          void Send_char(char c)
C51 COMPILER V9.59.0.0   MAIN_F0M1                                                         04/27/2021 15:55:32 PAGE 18  

1035          {
1036   1        
1037   1        //Desactive reception
1038   1        
1039   1        REN0 = 0;
1040   1        SBUF0 = c;
1041   1        
1042   1        //Attente fin de transmission
1043   1        while(!TI0){}
1044   1          
1045   1        //Remise à 0 du flag d'envoi une fois qu'on est sur que le caractere a été transmis
1046   1        TI0 = 0;
1047   1        REN0 = 1;
1048   1      }
1049          
1050          void Send_string(char* mot)
1051          {
1052   1        
1053   1        //Tant qu'on n'a pas fini de lire toute la chaine
1054   1          while (*mot != '\0'){
1055   2            
1056   2            //Check si on est en train de lire l'avant-dernier caractere (le tout dernier caractere est l'appuie de
             - la touche ENTER)
1057   2            Send_char(*mot);
1058   2            
1059   2            mot++;
1060   2          }
1061   1          
1062   1          Send_char('\r');
1063   1          Send_char('\n'); //Retour à la ligne
1064   1      }
1065          
1066          
1067          
1068          //-----------------------------------------------------------------------------
1069          // Recup_char sous-routine de récupération des char 
1070          //-----------------------------------------------------------------------------
1071          char Recup_char(void)
1072          {
1073   1          
1074   1        char c;
1075   1      
1076   1        //Desactive la reception
1077   1        RI0 = 0;
1078   1        REN0 = 0;
1079   1        
1080   1        //Recup le caractere
1081   1        c = SBUF0;
1082   1        
1083   1        //Reactive la reception
1084   1        REN0 = 1;
1085   1        
1086   1        return c;
1087   1      }
1088          
1089          
1090          //-----------------------------------------------------------------------------
1091          // Sous-routine  decoup_clef_val de découpage clef valeur des param complexes.
1092          //-----------------------------------------------------------------------------
1093          void decoup_clef_val(char* param, char* buf_clef, char* buf_val)
1094          {
1095   1        if(*param == '\0'){
C51 COMPILER V9.59.0.0   MAIN_F0M1                                                         04/27/2021 15:55:32 PAGE 19  

1096   2              *buf_clef = '\0';
1097   2              *buf_val = '\0';
1098   2          }
1099   1          else{
1100   2              //On prend tous les caracteres jusqu'au ':' exclus dans clef
1101   2              while(*param != ':')
1102   2              {
1103   3                      *buf_clef = *param;
1104   3                      buf_clef++;
1105   3              param++;
1106   3              }
1107   2              //Ici on passe les ':'
1108   2              param++;
1109   2          
1110   2              //Puis on lit tout ce qui suit les ':' jusqu'a la fin de la chaine
1111   2              while(*param != '\0')
1112   2              {
1113   3                  *buf_val = *param;
1114   3                  buf_val++;
1115   3                  param++;
1116   3              }
1117   2          }
1118   1      }
1119          //-----------------------------------------------------------------------------
1120          // Sous-routine d'analyse de la chaîne reçu
1121          //-----------------------------------------------------------------------------
1122          char separ_cmd(char* ptr_lecture, char* ptr_buffer){
1123   1      
1124   1      // La fonction returne -1 si il n'y a rien ( ou plus rien à lire) dans le buffer de lecture donné.
1125   1      
1126   1        
1127   1          //On passe les espaces.
1128   1          while(*ptr_lecture == ' '){
1129   2              ptr_lecture++;
1130   2              RX_ptr++;
1131   2          }
1132   1      
1133   1          // cas chaine vide ou avec plus rien à lire
1134   1          if(*ptr_lecture == '\r' || *ptr_lecture == '\0'){
1135   2              return -1;
1136   2          }
1137   1      
1138   1          //On itère dans notre chaine de char
1139   1          while(*ptr_lecture != '\r' && *ptr_lecture != '\0' && *ptr_lecture != ' '){
1140   2              //Copie du char dans le buffer
1141   2              *ptr_buffer = *ptr_lecture;
1142   2              *(ptr_buffer+1) = '\0';
1143   2              ptr_lecture++;
1144   2              RX_ptr++;
1145   2              ptr_buffer++;
1146   2          }
1147   1          return 0;
1148   1        }
1149          
1150            
1151          //-----------------------------------------------------------------------------
1152          // analyse_cmd Sous-routine d'analyse de commande
1153          //-----------------------------------------------------------------------------
1154          void analyse_cmd(void)
1155            {
1156   1          commande_valide = 1;
1157   1          if(strcmp(CMD, "D") == 0)
C51 COMPILER V9.59.0.0   MAIN_F0M1                                                         04/27/2021 15:55:32 PAGE 20  

1158   1            {
1159   2            s_cmd = 1;
1160   2            }
1161   1        else if(strcmp(CMD, "E") == 0)
1162   1          {
1163   2            s_cmd = 2;
1164   2          }
1165   1        else if(strcmp(CMD, "Q") == 0)
1166   1        {
1167   2          s_cmd = 3;
1168   2        }
1169   1        else if(strcmp(CMD, "TV") == 0)
1170   1          {
1171   2          s_cmd = 4;
1172   2          }
1173   1        else if(strcmp(CMD, "A") == 0)
1174   1          {
1175   2          s_cmd = 5;
1176   2          }
1177   1        else if(strcmp(CMD, "B") == 0)
1178   1          {
1179   2          s_cmd = 6;
1180   2          }
1181   1        else if(strcmp(CMD, "S") == 0)
1182   1          {
1183   2          s_cmd = 7;
1184   2          }
1185   1        else if(strcmp(CMD, "RD") == 0)
1186   1          {
1187   2          s_cmd = 8;
1188   2          }
1189   1        else if(strcmp(CMD, "RG") == 0)
1190   1          {
1191   2          s_cmd = 9;
1192   2          } 
1193   1        else if(strcmp(CMD, "RC") == 0)
1194   1          {
1195   2          s_cmd = 10;
1196   2          }
1197   1        else if(strcmp(CMD, "RA") == 0)
1198   1          {
1199   2          s_cmd = 11;
1200   2        }
1201   1        else if(strcmp(CMD, "G") == 0)
1202   1          {
1203   2          s_cmd = 12;
1204   2        }
1205   1        else if(strcmp(CMD, "ASS") == 0)
1206   1          {
1207   2          s_cmd = 13;
1208   2        }
1209   1        else if(strcmp(CMD, "MI") == 0)
1210   1          {
1211   2          s_cmd = 14;
1212   2        }
1213   1        else if(strcmp(CMD, "ME") == 0)
1214   1          {
1215   2          s_cmd = 15;
1216   2        }
1217   1        else if(strcmp(CMD, "IPO") == 0)
1218   1          {
1219   2          s_cmd = 16;
C51 COMPILER V9.59.0.0   MAIN_F0M1                                                         04/27/2021 15:55:32 PAGE 21  

1220   2        }
1221   1        else if(strcmp(CMD, "POS") == 0)
1222   1          {
1223   2          s_cmd = 17;
1224   2        }
1225   1        else if(strcmp(CMD, "MOU") == 0)
1226   1          {
1227   2          s_cmd = 18;
1228   2        }
1229   1        else if(strcmp(CMD, "MOB") == 0)
1230   1          {
1231   2          s_cmd = 19;
1232   2        }
1233   1        else if(strcmp(CMD, "MOS") == 0)
1234   1          {
1235   2          s_cmd = 20;
1236   2        }
1237   1        else if(strcmp(CMD, "SD") == 0)
1238   1          {
1239   2          s_cmd = 21;
1240   2        }
1241   1        else if(strcmp(CMD, "L") == 0)
1242   1          {
1243   2          s_cmd = 22;
1244   2        }
1245   1        else if(strcmp(CMD, "LS") == 0)
1246   1          {
1247   2          s_cmd = 23;
1248   2        }
1249   1        else if(strcmp(CMD, "CS") == 0)
1250   1          {
1251   2          s_cmd = 24;
1252   2        }
1253   1          else if(strcmp(CMD, "PPH") == 0)
1254   1          {
1255   2          s_cmd = 25;
1256   2        }
1257   1          else if(strcmp(CMD, "SPH") == 0)
1258   1          {
1259   2          s_cmd = 26;
1260   2        }
1261   1          else if(strcmp(CMD, "AUX") == 0)
1262   1          {
1263   2          s_cmd = 27;
1264   2            
1265   2          }
1266   1          else 
1267   1            {
1268   2              s_cmd = 28;
1269   2              commande_valide = 0;
1270   2            }
1271   1        // Cas commande inconnue
1272   1        //else {commande_valide = 0;}
1273   1        
1274   1        //Affichage retour selon si la commande est connue ou non
1275   1        switch(commande_valide){
1276   2          case 0:
1277   2            
1278   2            //Si pas valide : accusé non reception :  CR + LF + #
1279   2          
1280   2            //Send_char(0x0D);
1281   2            //Send_char(0x0A);
C51 COMPILER V9.59.0.0   MAIN_F0M1                                                         04/27/2021 15:55:32 PAGE 22  

1282   2            //Send_char(0x23);
1283   2            break;
1284   2          
1285   2          //valide
1286   2          default: // Si valide : accusé reception :  CR + LF + >
1287   2            Send_char(0x0D);
1288   2            Send_char(0x0A);
1289   2            Send_char(0x3E);
1290   2            break;
1291   2        }
1292   1      }
1293            
1294          
1295          
1296          
1297          //-----------------------------------------------------------------------------
1298          // Sous routine de Reset_buff_ptr
1299          //-----------------------------------------------------------------------------
1300          void Reset_buff_ptr(){
1301   1        
1302   1      // On initialise nos buffers à vide pour être certain de connaitre leur contenu 
1303   1            RX_ptr = &RX_Buf[0]; // On re place le ptr au début.
1304   1            
1305   1            strcpy(CMD, "");
1306   1            ptr_CMD = &CMD[0];
1307   1            
1308   1            strcpy(PARAM_1, "");
1309   1            ptr_PARAM_1 = &PARAM_1[0];
1310   1            
1311   1            strcpy(PARAM_2, "");
1312   1            ptr_PARAM_2 = &PARAM_2[0];
1313   1            
1314   1            strcpy(PARAM_3, "");
1315   1            ptr_PARAM_3 = &PARAM_3[0];
1316   1            
1317   1            strcpy(PARAM_4, "");
1318   1            ptr_PARAM_4 = &PARAM_4[0];
1319   1      
1320   1        }
1321            
1322          //-----------------------------------------------------------------------------
1323          // Struct_init Sous-routine d'analyse de commande
1324          //-----------------------------------------------------------------------------
1325          void Struct_init(void)
1326          {
1327   1        commandes.Etat_Epreuve = Epreuve_non;
1328   1        commandes.Etat_Mouvement = Mouvement_non;
1329   1        
1330   1        commandes.Etat_ACQ_Son = ACQ_non;
1331   1        commandes.Etat_DCT_Obst = DCT_non;
1332   1        commandes.Etat_Lumiere = Lumiere_non;
1333   1        commandes.Etat_Servo = Servo_non;
1334   1        commandes.Etat_Energie = Energie_non;
1335   1        commandes.Etat_Position = Position_non;
1336   1        commandes.Etat_Photo = Photo_non;
1337   1        
1338   1        commandes.V_defaut = 20;
1339   1        
1340   1        
1341   1      }
1342          //-----------------------------------------------------------------------------
1343          // Interrupt Handlers
C51 COMPILER V9.59.0.0   MAIN_F0M1                                                         04/27/2021 15:55:32 PAGE 23  

1344          //-----------------------------------------------------------------------------


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   7733    ----
   CONSTANT SIZE    =    176    ----
   XDATA SIZE       =    222      16
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      2    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
